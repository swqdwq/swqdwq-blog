---
title: 算法模板
published: 2025-12-16
description: ''
image: ''
tags: []
category: ''
draft: false 
lang: 'zh_CN'

---



# Template

## 0.template

```C++
#include <bits/stdc++.h>
using namespace std;

using u32 = unsigned;
using i64 = long long;
using i128 = __int128;

constexpr int inf = 0x3f3f3f3f;
constexpr i64 INF = 0x3f3f3f3f3f3f3f3f;

#define all(x, d) x.begin() + d, x.end()
#define range(x, l, r) x.begin() + l, x.begin() + r + 1
#define unq(x) sort(x.begin(), x.end()), x.erase(unique(x.begin(), x.end()), x.end())

template<class T>
bool chmax(T& a, T b) { if (a >= b) return false; a = b; return true; }
template<class T>
bool chmin(T& a, T b) { if (a <= b) return false; a = b; return true; }
template<class T>
T lowerp(T n, T k, bool eq = 1) { return eq ? n / k * k : (n - 1) / k * k;}
template<class T>
T upperp(T n, T k, bool eq = 1) { return eq ? (n + k - 1) / k * k : (n + k) / k * k;}

i128 ceilDiv(i128 n, i128 m) {
    assert(m);
    if (m < 0) n = -n, m = -m;
    return n >= 0 ? (n + m - 1) / m : n / m;
}
i128 floorDiv(i128 n, i128 m) {
    assert(m);
    if (m < 0) n = -n, m = -m;
    return n >= 0 ? n / m : (n - m + 1) / m;
}

// #pragma GCC optimize("O3")
// #pragma GCC optimize("Ofast")
// #pragma GCC optimize("unroll-loops")

//pbds
include<bits / extc++.h>
using namespace __gnu_pbds;
template <class T>
using rbtree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <class T>
using pheap = __gnu_pbds::priority_queue<T, greater<T>, pairing_heap_tag>;

//#define _GLIBCXX_DEBUG//后续自己添加的，判断STL是否越界

void solve() {

}

signed main() {
    cin.tie(0)->sync_with_stdio(false);
    int t;
    t = 1;
    while (t--)solve();
    return 0;
}
```



vscode配置：

运行 — launch.json—tasks.json

在settings.json里面改 cpp.default.complierPath

并在cpp.properties.json里加compilerPath：

搜格式化打三个√

搜format 改vc.format



# 数据结构

#### [0]离散化

```C++
struct Dis {
    vector<int>p;
    Dis() {}
    Dis(vector<int>a) :p(a) {
        init();
    }
    void init() {
        sort(all(p, 0));
        p.resize(unique(all(p, 0)) - p.begin());
    }
    void add(int v) { p.push_back(v); }
    int id(int v) {
        return lower_bound(all(p, 0), v) - p.begin() + 1;
    }
};
```



#### [1]并查集

```C++
struct DSU {
    vector<int> fa, siz;
    DSU() {}
    DSU(int n) { init(n); }
    void init(int n) {
        fa.resize(n);
        iota(fa.begin(), fa.end(), 0);
        siz.assign(n, 1);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    bool merge(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        fa[y] = x;
        return true;
    }
    bool Heuristic_merge(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) {
            return false;
        }
        if (siz[x] < siz[y]) swap(x, y);
        siz[x] += siz[y];
        fa[y] = x;
        return true;
    }
    int size(int x) {
        return siz[find(x)];
    }
};
```

#### [2]树状数组

```C++
template<typename T>
struct BIT {
    int n;
    vector<T>tr;
    BIT() {};
    BIT(int n) :n(n - 1), tr(n, T()) {}
    int lowbit(int x) {
        return ((x) & (-x));
    }
    void add(int i, T x) {
        while (i <= n) {
            tr[i] += x;
            i += lowbit(i);
        }
    }
    T sum(int i) {
        T res = T();
        while (i > 0) {
            res += tr[i];
            i -= lowbit(i);
        }
        return res;
    }
    T sum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
    int find_first(T sum) {
        int ans = 0; T val = 0;
        for (int i = __lg(n); i >= 0; i--) {
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] < sum) {
                ans |= 1 << i;
                val += tr[ans];
            }
        }
        return ans + 1;
    }
    int find_last(T sum) {
        int ans = 0; T val = 0;
        for (int i = __lg(n); i >= 0; i--) {
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] <= sum) {
                ans |= 1 << i;
                val += tr[ans];
            }
        }
        return ans;
    }
};

template<typename U>
struct MAX {
    U v;
    MAX(U _v = numeric_limits<U>::min()) : v(_v) {}
    MAX& operator+=(MAX const& o) {
        if (o.v > v) v = o.v;
        return *this;
    }
    operator U() const { return v; }
};

template<typename U>
struct MIN {
    U v;
    MIN(U _v = numeric_limits<U>::max()) : v(_v) {}
    MIN& operator+=(MIN const& o) {
        if (o.v < v) v = o.v;
        return *this;
    }
    operator U() const { return v; }
};

template<typename T>
struct RangeBIT {
    BIT<T>a, b;
    RangeBIT(int n) :a(n + 1), b(n + 1) {}
    void add(int l, int r, T x) {
        a.add(l, x);
        a.add(r + 1, -x);
        b.add(l, x * (l - 1));
        b.add(r + 1, -x * r);
    }
    T sum(int i) {
        return a.sum(i) * i - b.sum(i);
    }
    T sum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
};
```

#### [3]线段树扩展

```C++
    //树上二分
    template<class F>
    int findFirst(int p, int rtl, int rtr, int x, int y, F pred) {
        if (rtl > y || rtr < x || !pred(info[p])) {
            return -1;
        }
        if (rtl == rtr) {
            return rtl;
        }
        int res = findFirst(ls, rtl, mid, x, y, pred);
        if (res == -1) {
            res = findFirst(rs, mid + 1, rtr, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findFirst(int x, int y, F pred) {
        return findFirst(1, 1, n, x, y, pred);
    }
   //树上暴力
  void change(int p, int rtl, int rtr, int x, int y) {
        if (rtl == rtr) {
            info[p].MAX = info[p].sum = sqrt(info[p].sum);
            return;
        }
        down(p);
        if (x <= mid && info[ls].MAX > 1)change(ls, rtl, mid, x, y);
        if (mid < y && info[rs].MAX>1)change(rs, mid + 1, rtr, x, y);
        up(p);
    }
    void change(int x, int y) {
        change(1, 1, n, x, y);
    }
```

#### [4]懒标记线段树

```C++
template<class Info, class Tag>
struct SegmentTree {
#define ls p<<1
#define rs p<<1|1
#define mid (rtl+rtr>>1)
    int n;
    vector<Info>info;
    vector<Tag>tag;

    SegmentTree(int _n) {
        this->n = _n - 1;
        info.resize(4 << __lg(_n));
        tag.resize(4 << __lg(_n));
    }
    SegmentTree(vector<Info>a) :SegmentTree((int)a.size()) {
        function<void(int, int, int)> build = [&] (int p, int rtl, int rtr) {
            if (rtr == rtl) {
                info[p] = a[rtl];
                return;
            }
            build(ls, rtl, mid);
            build(rs, mid + 1, rtr);
            up(p);
        };
        build(1, 1, n);
    }
    void up(int p) {
        info[p] = info[ls] + info[rs];
    }
    void apply(int p, const Tag& v) {
        info[p].apply(v);
        tag[p].apply(v);
    }
    void down(int p) {
        apply(ls, tag[p]);
        apply(rs, tag[p]);
        tag[p] = {};
    }
    void modify(int p, int rtl, int rtr, int x, const Info& v) {
        if (rtl == rtr) {
            info[p] = v;
            return;
        }
        down(p);
        if (x <= mid) {
            modify(ls, rtl, mid, x, v);
        } else {
            modify(rs, mid + 1, rtr, x, v);
        }
        up(p);
    }
    void modify(int x, const Info& v) {
        modify(1, 1, n, x, v);
    }
    Info query(int p, int rtl, int rtr, int x, int y) {
        if (rtl > y || rtr < x)return Info{};
        if (x <= rtl && rtr <= y) {
            return info[p];
        }
        down(p);
        return query(ls, rtl, mid, x, y) + query(rs, mid + 1, rtr, x, y);
    }
    Info query(int x, int y) {
        return query(1, 1, n, x, y);
    }
    void update(int p, int rtl, int rtr, int x, int y, const Tag& v) {
        if (rtl > y || rtr < x)return;
        if (x <= rtl && rtr <= y) {
            apply(p, v);
            return;
        }
        down(p);
        update(ls, rtl, mid, x, y, v);
        update(rs, mid + 1, rtr, x, y, v);
        up(p);
    }
    void update(int x, int y, const Tag& v) {
        update(1, 1, n, x, y, v);
    }
};

struct Tag {
    void apply(Tag t) {

    }
};

struct Info {
    int len = 1;
    i64 sum = 0, l0 = 0, r0 = 0;
    void apply(Tag t) {

    }
};

Info operator+(const Info& a, const Info& b) {
    Info c;
    c.len = a.len + b.len;
    c.l0 = (a.l0 == a.len) ? a.l0 + b.l0 : a.l0;
    c.r0 = (b.r0 == b.len) ? a.r0 + b.l0 : b.r0;
    c.sum = a.sum + b.sum + 1LL * a.r0 * b.l0;
    return c;
}

//改0下标
//1 _n-1 ->_n
//2 rtr == rtl->rtr - 1 == rtl
//3 mid+1->mid
//4 <=mid -> <mid
//5 (1,1,n,...)->(1,0,n,...)
//6 >y||<x  -> >=y|| <=x
```

#### [5]treap其一

```C++
struct treap {
    struct item {
        int prior, value, cnt;
        bool rev;
        item* l, * r;
    };

    item* root{ nullptr };

    auto getRng() -> int { return (rand() << 16) ^ rand(); }

    int cnt(item* it) { return it ? it->cnt : 0; }

    void updCnt(item* it) {
        if (it) it->cnt = cnt(it->l) + cnt(it->r) + 1;
    }

    void push(item* it) {
        if (it && it->rev) {
            it->rev = false;
            swap(it->l, it->r);
            if (it->l) it->l->rev ^= true;
            if (it->r) it->r->rev ^= true;
        }
    }

    void merge(item*& t, item* l, item* r) {
        push(l);
        push(r);
        if (!l) t = r;
        else if (!r) t = l;
        else if (l->prior > r->prior) merge(l->r, l->r, r), t = l;
        else merge(r->l, l, r->l), t = r;
        updCnt(t);
    }

    void split(item* t, item*& l, item*& r, int key, int add = 0) {
        if (!t) return void(l = r = nullptr);
        push(t);

        int cur_key = add + cnt(t->l);
        if (key <= cur_key) split(t->l, l, t->l, key, add), r = t;
        else split(t->r, t->r, r, key, add + 1 + cnt(t->l)), l = t;
        updCnt(t);
    }

    int getValue(item* t, int pos) {
        if (t) push(t);
        int lCnt = cnt(t->l);
        if (pos < lCnt) return getValue(t->l, pos);
        else if (pos == lCnt) return t->value;
        else return getValue(t->r, pos - lCnt - 1);
    }

    item* newItem(int val) { return new item{ getRng(), val, 1, false }; }

    void replace(int pos, int l, int r) {
        item* t1, * t2, * t3, * t4;
        split(root, t1, t2, pos);
        split(t2, t3, t4, 1);
        item* lI = newItem(l), * rI = newItem(r);
        merge(root, t1, lI);
        merge(root, root, rI);
        merge(root, root, t4);
    }

    void add(int val) { merge(root, root, newItem(val)); }

    int operator[](int pos) { return getValue(root, pos); }

    void reverse(int l, int r) {
        item* t1, * t2, * t3, * t4;
        split(root, t1, t2, r);
        split(t1, t3, t4, l - 1);
        t4->rev ^= true;
        merge(root, t3, t4);
        merge(root, root, t2);
    }
};
```

#### [6]treap其二

```C++
struct treap {
    struct item {
        int prior, value, cnt;
        item* l, * r;
    };

    item* root{ nullptr };

    auto getRng() -> int { return (rand() << 16) ^ rand(); }

    int cnt(item* it) { return it ? it->cnt : 0; }

    void updCnt(item* it) {
        if (it) it->cnt = cnt(it->l) + cnt(it->r) + 1;
    }

    void merge(item*& t, item* l, item* r) {
        if (!l) t = r;
        else if (!r) t = l;
        else if (l->prior > r->prior) merge(l->r, l->r, r), t = l;
        else merge(r->l, l, r->l), t = r;
        updCnt(t);
    }

    void split(item* t, item*& l, item*& r, int v) {
        if (!t) return void(l = r = nullptr);

        if (t->value > v) {
            r = t;
            split(t->l, l, t->l, v);
        }
        else {
            l = t;
            split(t->r, t->r, r, v);
        }
        updCnt(t);
    }

    void split_cnt(item* t, item*& l, item*& r, int key, int add = 0) {
        if (!t) return void(l = r = nullptr);
        int cur_key = add + cnt(t->l);
        if (key <= cur_key) split_cnt(t->l, l, t->l, key, add), r = t;
        else split_cnt(t->r, t->r, r, key, add + 1 + cnt(t->l)), l = t;
        updCnt(t);
    }

    int getValue(item* t, int pos) {
        int lCnt = cnt(t->l);
        if (pos < lCnt) return getValue(t->l, pos);
        else if (pos == lCnt) return t->value;
        else return getValue(t->r, pos - lCnt - 1);
    }

    item* newItem(int val) { return new item{ getRng(), val, 1 }; }

    int operator[](int pos) { return getValue(root, pos); }

    void insert(int v) {
        item* t1, * t2;
        split(root, t1, t2, v);
        merge(root, t1, newItem(v));
        merge(root, root, t2);
    }

    void erase(int x) {
        item* t1, * t2, * t3;
        split(root, t1, t2, x);
        split(t1, t1, t3, x - 1);
        merge(t3, t3->l, t3->r);
        merge(t1, t1, t3);
        merge(root, t1, t2);
    }

    int rank(int x) {
        item* t1, * t2;
        split(root, t1, t2, x - 1);
        int res = cnt(t1);
        merge(root, t1, t2);
        return res;
    }

    int kth(int x) {
        item* u = root;
        while (u) {
            int tmp = cnt(u->l) + 1;
            if (tmp == x)break;
            else if (tmp > x)u = u->l;
            else x -= tmp, u = u->r;
        }
        return (u->value);
    }

    int pre(item* t, int x) {
        if (!t)return -inf;
        if (t->value < x) {
            int res = pre(t->r, x);
            return res == -inf ? t->value : res;
        }
        else {
            return pre(t->l, x);
        }
    }

    int suf(item* t, int x) {
        if (!t)return inf;
        if (t->value > x) {
            int res = suf(t->l, x);
            return res == inf ? t->value : res;
        }
        else {
            return suf(t->r, x);
        }
    }
};
```

#### [7]主席树

```C++
const int maxn = 1e6 + 5;

struct Tree {
    int l = 0, r = 0;
    int val = 0;
}tr[maxn * 30];

int tot = 0, rt[maxn];

void insert(int& now, int last, int l, int r, int pos, int val) {
    now = ++tot; tr[now] = tr[last];
    tr[now].val = val;//这里写主要逻辑
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (pos <= mid) insert(tr[now].l, tr[last].l, l, mid, pos, val);
    else insert(tr[now].r, tr[last].r, mid + 1, r, pos, val);
}

int query(int now, int l, int r, int pos) {
    if (l == r) return tr[now].val;
    int mid = (l + r) >> 1;
    if (pos <= mid) return query(tr[now].l, l, mid, pos);
    else return query(tr[now].r, mid + 1, r, pos);
}
//第k大
int query(int t1, int t2, int l, int r, int k) {
    if (l == r)return l;
    int mid = (l + r) >> 1, siz = tr[tr[t2].l].val - tr[tr[t1].l].val;
    if (siz >= k)return query(tr[t1].l, tr[t2].l, l, mid, k);
    else return query(tr[t1].r, tr[t2].r, mid + 1, r, k - siz);
}

auto build = [&] (auto self, int& now, int l, int r) -> void {
    now = ++tot;
    if (l == r) { tr[now].val = init[l]; return; }
    int mid = (l + r) >> 1;
    self(self, tr[now].l, l, mid);
    self(self, tr[now].r, mid + 1, r);
};
build(build, rt[0], 1, n);
```

#### [8]ST表/RMQ

```C++
template<class T>
struct RMQ {
    vector<vector<T>>st;
    vector<int>LOG;
    int n;
    RMQ(const vector<T>& a) {
        this->n = (int)a.size() - 1;
        LOG.resize(n + 1);
        for (int i = 2; i <= n; i++)LOG[i] = LOG[i / 2] + 1;
        st.resize(n + 1, vector<T>(LOG[n] + 1));
        for (int i = 1; i <= n; i++)st[i][0] = a[i];
        for (int j = 1; 1 << j <= n; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
            }
        }
    }
    T operator() (int L, int R) {
        assert(L <= R);
        int j = LOG[R - L + 1];
        return max(st[L][j], st[R - (1 << j) + 1][j]);
    }
};


template<class F = function<int(const int&, const int&)>>
struct RMQ {
    vector<vector<int>>st;
    vector<int>LOG;
    F func;
    int n;

    RMQ(const vector<int>& a, const F& f) :func(f) {
        this->n = (int) a.size() - 1;
        LOG.resize(n + 1);
        for (int i = 2; i <= n; i++)LOG[i] = LOG[i / 2] + 1;

        st.resize(n + 1, vector<int>(LOG[n] + 1));
        for (int i = 1; i <= n; i++)st[i][0] = a[i];
        for (int j = 1; 1 << j <= n; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                st[i][j] = func(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
            }
        }
    }

    int operator()(int L, int R) {
        assert(L <= R);
        int j = LOG[R - L + 1];
        return func(st[L][j], st[R - (1 << j) + 1][j]);
    }
};
```

#### [9]单调栈

```C++
 struct node {
        int no, val;
    };
    vector<int>first_left_bigger(n + 1), first_left_smaller(n + 1), first_right_bigger(n + 1), first_right_smaller(n + 1);
    vector<int>cnt_left_bigger(n + 1), cnt_left_smaller(n + 1), cnt_right_bigger(n + 1), cnt_right_smaller(n + 1);
    //其实下面的数组只是与上面相反关系，板子里面并不是bigger和smaller，而是要加上equal
    //特别注意：cnt求的不是左边小的个数，而是左边递增序列的长度，eg: 8 4 11  对于i==3来说，left small是1
    //真正要去求个数请用树状数组
    stack<node>st, st2;
    for (int i = 1; i <= n; i++) {
        while (!st.empty() && st.top().val < a[i]) {
            first_right_bigger[st.top().no] = i;
            st.pop();
        }
        if (!st.empty())cnt_left_bigger[i] = cnt_left_bigger[st.top().no] + 1;
        st.push({ i,a[i] });

        while (!st2.empty() && st2.top().val > a[i]) {
            first_right_smaller[st2.top().no] = i;
            st2.pop();
        }
        if (!st2.empty())cnt_left_smaller[i] = cnt_left_smaller[st2.top().no] + 1;
        st2.push({ i,a[i] });
    }
    while (!st.empty())st.pop();
    while (!st2.empty())st2.pop();
    for (int i = n; i >= 1; i--) {
        while (!st.empty() && st.top().val < a[i]) {
            first_left_bigger[st.top().no] = i;
            st.pop();
        }
        if (!st.empty())cnt_right_bigger[i] = cnt_right_bigger[st.top().no] + 1;
        st.push({ i,a[i] });

        while (!st2.empty() && st2.top().val > a[i]) {
            first_left_smaller[st2.top().no] = i;
            st2.pop();
        }
        if (!st2.empty())cnt_right_smaller[i] = cnt_right_smaller[st2.top().no] + 1;
        st2.push({ i,a[i] });
    }
```

#### [10]单调队列

```C++

```

#### [11]前缀和与差分(二维)

```C++
 vector<vector<i64>>sum(n + 1, vector<i64>(m + 1));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            sum[i][j] = -sum[i - 1][j - 1] + sum[i][j - 1] + sum[i - 1][j] + A[i][j];
        }
    }

    auto get = [&] (int a, int b, int x, int y)->i64 {
        return sum[x][y] + sum[a - 1][b - 1] - sum[a - 1][y] - sum[x][b - 1];
    };


    //差分
    auto add = [&] (int a, int b, int x, int y)->void {
        A[a][b]++;
        A[a][y + 1]--;
        A[x + 1][b]--;
        A[x + 1][y + 1]++;
    };
```

#### [12]线段树二维

```C++
template <typename T, typename F>
struct SegmentTree2D {
private:
    int id(int h, int w) const { return h * 2 * W + w; }

public:
    int H, W;
    vector<T> seg;
    const F f;
    const T I;

    SegmentTree2D(int h, int w, F _f, const T& i) : f(_f), I(i) { init(h, w); }

    void init(int h, int w) {
        H = W = 1;
        while (H < h) H <<= 1;
        while (W < w) W <<= 1;
        seg.assign(4 * H * W, I);
    }

    void set(int h, int w, const T& x) { seg[id(h + H, w + W)] = x; }

    void build() {
        for (int w = W; w < 2 * W; w++) {
            for (int h = H - 1; h; h--) {
                seg[id(h, w)] = f(seg[id(2 * h + 0, w)], seg[id(2 * h + 1, w)]);
            }
        }
        for (int h = 0; h < 2 * H; h++) {
            for (int w = W - 1; w; w--) {
                seg[id(h, w)] = f(seg[id(h, 2 * w + 0)], seg[id(h, 2 * w + 1)]);
            }
        }
    }

    T get(int h, int w) const { return seg[id(h + H, w + W)]; }
    T operator()(int h, int w) const { return seg[id(h + H, w + W)]; }

    void update(int h, int w, const T& x) {
        h += H, w += W;
        seg[id(h, w)] = x;
        for (int i = h >> 1; i; i >>= 1) {
            seg[id(i, w)] = f(seg[id(2 * i + 0, w)], seg[id(2 * i + 1, w)]);
        }
        for (; h; h >>= 1) {
            for (int j = w >> 1; j; j >>= 1) {
                seg[id(h, j)] = f(seg[id(h, 2 * j + 0)], seg[id(h, 2 * j + 1)]);
            }
        }
    }

    T _inner_query(int h, int w1, int w2) {
        T res = I;
        for (; w1 < w2; w1 >>= 1, w2 >>= 1) {
            if (w1 & 1) res = f(res, seg[id(h, w1)]), w1++;
            if (w2 & 1) --w2, res = f(res, seg[id(h, w2)]);
        }
        return res;
    }

    T query(int h1, int w1, int h2, int w2) {
        if (h1 >= h2 || w1 >= w2) return I;
        T res = I;
        h1 += H, h2 += H, w1 += W, w2 += W;
        for (; h1 < h2; h1 >>= 1, h2 >>= 1) {
            if (h1 & 1) res = f(res, _inner_query(h1, w1, w2)), h1++;
            if (h2 & 1) --h2, res = f(res, _inner_query(h2, w1, w2));
        }
        return res;
    }
};

//用法
 auto f1 = [&] (int x, int y)->int {
        return max(x, y);
    };
    auto f2 = [&] (int x, int y)->int {
        return min(x, y);
    };
    SegmentTree2D<int, decltype(f1)>trmax(a, b, f1, 0);
    SegmentTree2D<int, decltype(f2)>trmin(a, b, f2, inf);
    for (int i = 0; i < a; i++) {
        for (int j = 0; j < b; j++) {
            int x; cin >> x;
            trmax.set(i, j, x);
            trmin.set(i, j, x);
        }
    }
    trmax.build();
    trmin.build();
    int ans = inf;
    for (int i = 0; i + n - 1 < a; i++) {
        for (int j = 0; j + n - 1 < b; j++) {
            int MAX = trmax.query(i, j, i + n, j + n);
            int MIN = trmin.query(i, j, i + n, j + n);
            ans = min(ans, MAX - MIN);
        }
    }
```

#### [13]小波树

```C++
#include<immintrin.h>
struct bit_vector {
    using u32 = uint32_t;
    using i64 = int64_t;
    using u64 = uint64_t;
    static constexpr u32 w = 64;
    vector<u64> block;
    vector<u32> count;
    u32 n, zeros;
    inline u32 get(u32 i) const { return u32(block[i / w] >> (i % w)) & 1u; }
    inline void set(u32 i) { block[i / w] |= 1LL << (i % w); }
    bit_vector() {}
    bit_vector(int _n) { init(_n); }
    void init(int _n) {
        n = zeros = _n;
        block.resize(n / w + 1, 0);
        count.resize(block.size(), 0);
    }
    __attribute__((target("popcnt"))) void build() {
        for (u32 i = 1; i < block.size(); ++i)
            count[i] = count[i - 1] + _mm_popcnt_u64(block[i - 1]);
        zeros = rank0(n);
    }
    inline u32 rank0(u32 i) const { return i - rank1(i); }
    __attribute__((target("bmi2,popcnt"))) inline u32 rank1(u32 i) const {
        return count[i / w] + _mm_popcnt_u64(_bzhi_u64(block[i / w], i % w));
    }
};

template <typename T>
struct WaveletMatrix {
    using u32 = uint32_t;
    using i64 = int64_t;
    using u64 = uint64_t;
    int n, lg;
    vector<T> a;
    vector<bit_vector> bv;
    WaveletMatrix(u32 _n) : n(max<u32>(_n, 1)), a(n) {}
    WaveletMatrix(const vector<T>& _a) : n(_a.size()), a(_a) { build(); }
    void build() {
        lg = __lg(max<T>(*max_element(begin(a), end(a)), 1)) + 1;
        bv.assign(lg, n);
        vector<T> cur = a, nxt(n);
        for (int h = lg - 1; h >= 0; --h) {
            for (int i = 0; i < n; ++i)
                if ((cur[i] >> h) & 1) bv[h].set(i);
            bv[h].build();
            array<decltype(begin(nxt)), 2> it{ begin(nxt), begin(nxt) + bv[h].zeros };
            for (int i = 0; i < n; ++i) *it[bv[h].get(i)]++ = cur[i];
            swap(cur, nxt);
        }
        return;
    }
    void set(u32 i, const T& x) {
        assert(x >= 0);
        a[i] = x;
    }
    inline pair<u32, u32> succ0(int l, int r, int h) const {
        return make_pair(bv[h].rank0(l), bv[h].rank0(r));
    }
    inline pair<u32, u32> succ1(int l, int r, int h) const {
        u32 l0 = bv[h].rank0(l);
        u32 r0 = bv[h].rank0(r);
        u32 zeros = bv[h].zeros;
        return make_pair(l + zeros - l0, r + zeros - r0);
    }
    T get(u32 k) const {
        T ret = 0;
        for (int h = lg - 1; h >= 0; --h) {
            u32 f = bv[h].get(k);
            ret |= f ? T(1) << h : 0;
            k = f ? bv[h].rank1(k) + bv[h].zeros : bv[h].rank0(k);
        }
        return ret;
    }
    T kth_smallest(u32 l, u32 r, u32 k) const {
        T res = 0;
        for (int h = lg - 1; h >= 0; --h) {
            u32 l0 = bv[h].rank0(l), r0 = bv[h].rank0(r);
            if (k < r0 - l0)
                l = l0, r = r0;
            else {
                k -= r0 - l0;
                res |= (T) 1 << h;
                l += bv[h].zeros - l0;
                r += bv[h].zeros - r0;
            }
        }
        return res;
    }
    T kth_largest(int l, int r, int k) {
        return kth_smallest(l, r, r - l - k - 1);
    }
    int range_freq(int l, int r, T upper) {
        if (upper >= (T(1) << lg)) return r - l;
        int ret = 0;
        for (int h = lg - 1; h >= 0; --h) {
            bool f = (upper >> h) & 1;
            u32 l0 = bv[h].rank0(l), r0 = bv[h].rank0(r);
            if (f) {
                ret += r0 - l0;
                l += bv[h].zeros - l0;
                r += bv[h].zeros - r0;
            }
            else {
                l = l0;
                r = r0;
            }
        }
        return ret;
    }
    int range_freq(int l, int r, T lower, T upper) {
        return range_freq(l, r, upper) - range_freq(l, r, lower);
    }
    T prev_value(int l, int r, T upper) {
        int cnt = range_freq(l, r, upper);
        return cnt == 0 ? T(-1) : kth_smallest(l, r, cnt - 1);
    }
    T next_value(int l, int r, T lower) {
        int cnt = range_freq(l, r, lower);
        return cnt == r - l ? T(-1) : kth_smallest(l, r, cnt);
    }
};/*https://github.com/NyaanNyaan/library/blob/master/data-structure-2d/wavelet-matrix.hpp*/
```

#### [14]小波树二维数点

```C++
include<immintrin.h>
struct bit_vector {
    using u32 = uint32_t;
    using i64 = int64_t;
    using u64 = uint64_t;
    static constexpr u32 w = 64;
    vector<u64> block;
    vector<u32> count;
    u32 n, zeros;
    inline u32 get(u32 i) const { return u32(block[i / w] >> (i % w)) & 1u; }
    inline void set(u32 i) { block[i / w] |= 1LL << (i % w); }
    bit_vector() {}
    bit_vector(int _n) { init(_n); }
    __attribute__((optimize("O3,unroll-loops"))) void init(int _n) {
        n = zeros = _n;
        block.resize(n / w + 1, 0);
        count.resize(block.size(), 0);
    }
    __attribute__((target("popcnt"))) void build() {
        for (u32 i = 1; i < block.size(); ++i)
            count[i] = count[i - 1] + _mm_popcnt_u64(block[i - 1]);
        zeros = rank0(n);
    }
    inline u32 rank0(u32 i) const { return i - rank1(i); }

    __attribute__((target("bmi2,popcnt"))) inline u32 rank1(u32 i) const {
        return count[i / w] + _mm_popcnt_u64(_bzhi_u64(block[i / w], i % w));
    }
};

template <typename S, typename T>
struct WaveletMatrix {
    using u32 = uint32_t;
    using i64 = int64_t;
    using u64 = uint64_t;
    struct BIT {
        u32 N;
        vector<T> data;
        BIT() = default;
        BIT(int size) { init(size); }

        void init(int size) {
            N = size;
            data.assign(N + 1, 0);
        }
        __attribute__((target("bmi"))) void add(u32 k, T x) {
            for (++k; k <= N; k += _blsi_u32(k)) data[k] += x;
        }
        __attribute__((target("bmi"))) T sum(u32 k) const {
            T ret = T();
            for (; k; k = _blsr_u32(k)) ret += data[k];
            return ret;
        }
        __attribute__((target("bmi"))) T sum(int l, int r) const {
            T ret = T();
            while (l != r) {
                if (l < r) {
                    ret += data[r];
                    r = _blsr_u32(r);
                }
                else {
                    ret -= data[l];
                    l = _blsr_u32(l);
                }
            }
            return ret;
        }
    };
    using P = pair<S, S>;
    int n, lg;
    vector<bit_vector> bv;
    vector<BIT> bit;
    vector<P> ps;
    vector<S> ys;
    WaveletMatrix() {}
    void add_point(S x, S y) {
        ps.emplace_back(x, y);
        ys.emplace_back(y);
    }
    __attribute__((optimize("O3"))) void build() {
        sort(begin(ps), end(ps));
        ps.erase(unique(begin(ps), end(ps)), end(ps));
        n = ps.size();
        sort(begin(ys), end(ys));
        ys.erase(unique(begin(ys), end(ys)), end(ys));
        vector<u32> cur(n), nxt(n);
        for (int i = 0; i < n; ++i) cur[i] = yid(ps[i].second);
        lg = __lg(max(n, 1)) + 1;
        bv.assign(lg, n);
        bit.assign(lg, n);
        for (int h = lg - 1; h >= 0; --h) {
            for (int i = 0; i < n; ++i)
                if ((cur[i] >> h) & 1) bv[h].set(i);
            bv[h].build();
            array<decltype(begin(nxt)), 2> it{ begin(nxt), begin(nxt) + bv[h].zeros };
            for (int i = 0; i < n; ++i) *it[bv[h].get(i)]++ = cur[i];
            swap(cur, nxt);
        }
    }
    int xid(S x) const {
        return lower_bound(
            begin(ps), end(ps), make_pair(x, S()),
            [] (const P& a, const P& b) { return a.first < b.first; }) -
            begin(ps);
    }
    int yid(S y) const { return lower_bound(begin(ys), end(ys), y) - begin(ys); }
    void add(S x, S y, T val) {
        int i = lower_bound(begin(ps), end(ps), P{ x, y }) - begin(ps);
        for (int h = lg - 1; h >= 0; --h) {
            int i0 = bv[h].rank0(i);
            if (bv[h].get(i))
                i += bv[h].zeros - i0;
            else
                i = i0;
            bit[h].add(i, val);
        }
    }
    T sum(int l, int r, u32 upper) const {
        T res = 0;
        for (int h = lg; h--;) {
            int l0 = bv[h].rank0(l), r0 = bv[h].rank0(r);
            if ((upper >> h) & 1) {
                res += bit[h].sum(l0, r0);
                l += bv[h].zeros - l0;
                r += bv[h].zeros - r0;
            }
            else {
                l = l0, r = r0;
            }
        }
        return res;
    }
    T sum(S L, S D, S R, S U) const {
        int l = xid(L), r = xid(R);
        return sum(l, r, yid(U)) - sum(l, r, yid(D));
    }
};
```

#### [15]链表

```C++
  vector<int>L(n + 2), R(n + 2), a(n + 1);
        R[0] = 1, L[n + 1] = n;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
            L[i] = i - 1, R[i] = i + 1;
        }
        auto del = [&] (int c) {
            R[L[c]] = R[c];
            L[R[c]] = L[c];
        };
        
```

#### [16]bitset

```C++
a.set() //将所有位变成1
a.set(k) //将第k位变成1，超限会报错
a.reset() //清空bitset
a.reset(k) //把第k位变成0
a.flip() //将所有位按位取反
a.flip(k) //将第k位按位取反
a.count() //返回bitset中1的个数
a.all() //若bitset内全是1返回1，否则返回0
```

#### [17]普通莫队

```C++
 vector<int> w(n + 1), cnt(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> w[i];
    }

    vector<array<int, 3>> query(q + 1);
    for (int i = 1; i <= q; i++) {
        int l, r;
        cin >> l >> r;
        query[i] = { l, r, i };
    }

    int B = n / min<int>(n, sqrt(q));//sqrt(n)
    vector<int> K(n + 1);
    for (int i = 1; i <= n; i++) {
        K[i] = (i - 1) / B + 1;
    }
    sort(query.begin() + 1, query.end(), [&] (auto x, auto y) {
        if (K[x[0]] != K[y[0]]) return x[0] < y[0];
        if (K[x[0]] & 1) return x[1] < y[1];
        return x[1] > y[1];
    });

    int l = 1, r = 0, val = 1, sum = 0;
    vector<int> ans(q + 1);
    for (int i = 1; i <= q; i++) {
        auto [ql, qr, id] = query[i];

        auto add = [&] (int x) -> void {
            cnt[x]++;
            if (cnt[x] == 2) {
                sum++;
                val = 0;
            }
        };

        auto del = [&] (int x) -> void {
            cnt[x]--;
            if (cnt[x] == 1) {
                sum--;
                if (sum == 0)val = 1;
            }
        };

        while (l > ql) add(w[--l]);
        while (r < qr) add(w[++r]);
        while (l < ql) del(w[l++]);
        while (r > qr) del(w[r--]);
        ans[id] = val;
    }

    for (int i = 1; i <= q; i++) {
        cout << (ans[i] ? "Yes" : "No") << "\n";
    }
```



#### [18]带修莫队

```C++
 vector<int>w(n + 1);
    for (int i = 1; i <= n; i++)cin >> w[i];

    vector<array<int, 4>>query = { {} };
    vector<array<int, 2>>modify = { {} };

    for (int i = 1; i <= q; i++) {
        char op;
        cin >> op;
        if (op == 'Q') {
            int l, r;
            cin >> l >> r;
            query.push_back({ l, r, (int) modify.size() - 1, (int) query.size() });
        } else {
            int idx, w;
            cin >> idx >> w;
            modify.push_back({ w, idx });
        }
    }

    int B = n / min<int>(n, sqrt(q));
    vector<int> K(n + 1);
    for (int i = 1; i <= n; i++) {
        K[i] = (i - 1) / B + 1;
    }

    sort(query.begin() + 1, query.end(), [&] (auto x, auto y) {
        if (K[x[0]] != K[y[0]]) return x[0] < y[0];
        if (K[x[1]] != K[y[1]]) return x[1] < y[1];
        return x[3] < y[3];
    });

    int l = 1, r = 0, val = 0;
    int t = 0;
    vector<int> ans(query.size());
    for (int i = 1; i < query.size(); i++) {
        auto [ql, qr, qt, id] = query[i];

        auto add = [&] (int x) -> void {
            val += !cnt[x]++;
        };

        auto del = [&] (int x) -> void {
            val -= !--cnt[x];
        };

        auto time = [&] (int x, int l, int r) -> void {
            int pos = modify[x][1], & ww = modify[x][0];
            if (l <= pos && pos <= r) {
                del(w[pos]);
                add(ww);
            }
            swap(ww, w[pos]);
        };

        while (l > ql) add(w[--l]);
        while (r < qr) add(w[++r]);
        while (l < ql) del(w[l++]);
        while (r > qr) del(w[r--]);
        while (t < qt) time(++t, ql, qr);
        while (t > qt) time(t--, ql, qr);
        ans[id] = val;
    }

    for (int i = 1; i < ans.size(); i++)cout << ans[i] << "\n";
```

#### [19]珂朵莉

```C++
template<class T>
struct ChthollyTree {
private:
    struct Node {
        int l, r;
        mutable T v;
        Node(const int& l, const int& r, const T& v) : l(l), r(r), v(v) {}
        bool operator<(const Node& rhs) const { return l < rhs.l; }
    };
    auto split(int x) {
        auto it = s.lower_bound(Node{ x,0,0 });
        if (it != s.end() && it->l == x) return it;
        it--;
        int l = it->l, r = it->r;
        T v = it->v;
        s.erase(it);
        s.insert(Node{ l, x - 1, v });
        return s.insert(Node{ x, r, v }).first;
    }
    auto split(int l, int r) {
        auto rt = split(r + 1), lt = split(l);
        return make_pair(lt, rt);
    }
    void merge(int l, int r, const T& v) {
        auto [rt, lt] = split(l, r);
        s.erase(lt, rt);
        s.insert(Node{ l, r, v });
    }
    void merge(int l, int r, T&& v) {
        auto [rt, lt] = split(l, r);
        s.erase(lt, rt);
        s.insert(Node{ l, r, move(v) });
    }
public:
    set<Node>s;
    void insert(int l, int r, const T& v) {
        s.insert({ l, r, v });
    }
    void insert(int l, int r, T&& v) {
        s.insert({ l, r, move(v) });
    }
    void erase(int l, int r) {
        auto [rt, lt] = split(l, r);
        s.erase(lt, rt);
    }
    auto extract(int l, int r) {
        return split(l, r);
    }
    void assign(int l, int r, int v) {
        auto [_l, _r] = extract(l, r);
        s.erase(_l, _r);
        s.insert(Node(l, r, v));
    }
    friend ostream& operator<<(ostream& os, const ChthollyTree& ct) {
        os << "ChthollyTree {\n";
        for (auto [l, r, v] : ct.s) {
            os << l << ' ' << r << ' ' << v << "\n";
        }
        os << "}";
        return os;
    }
};

ChthollyTree<i64>coly;
```



# 字符串

#### [1]字典树

```C++
template <const int M = 62>
struct Trie {
    vector<array<int, M>>son;
    vector<int>cnt, pref;
    //i64 sum[M + 2][M + 2]{};
    int idx;

    Trie() {}

    Trie(int totmullen) {
        son.resize(totmullen, array<int, M>());
        cnt.resize(totmullen);
        pref.resize(totmullen);
        idx = 0;
        init(totmullen);
    }

    void init(int totmullen) {
        for (int i = 0; i <= idx; i++)for (int j = 0; j < M; j++)son[i][j] = 0;
        for (int i = 0; i <= idx; i++)cnt[i] = 0;
        for (int i = 0; i <= idx; i++)pref[i] = 0;
        idx = 0;
    }

    int getnum(char x) {
        if (M == 26) {
            if (x >= 'A' && x <= 'Z')return x - 'A';
            else return x - 'a';
        } else if (M == 52) {
            if (x >= 'A' && x <= 'Z')return x - 'A';
            else return x - 'a' + 26;
        } else {
            if (x >= '0' && x <= '9')
                return x - '0';
            else if (x >= 'A' && x <= 'Z')
                return x - 'A' + 10;
            else
                return x - 'a' + 36;
        }
    }

    void insert(string s) {
        int p = 0;
        for (int i = 0; i < s.size(); i++) {
            int u = getnum(s[i]);
            if (!son[p][u]) son[p][u] = ++idx;
            // for (int j = 0; j < 26; j++) {
            //     if (i < s.size()) {
            //         sum[j][getnum(s[i])] += pref[son[p][j]];
            //     }
            // }
            p = son[p][u];
            pref[p]++;
        }
        // for (int j = 0; j < 26; j++) {
        //     sum[j][26] += pref[son[p][j]];
        // }
        cnt[p]++;
    }

    pair<int, int> query(string s) {
        int p = 0;
        for (int i = 0; i < s.size(); i++) {
            int u = getnum(s[i]);
            if (!son[p][u]) return { 0,0 };
            p = son[p][u];
        }
        return { cnt[p],pref[p] };
    }//pref以该字符串为前缀的串有几个

    int query_sub(string s) {
        int p = 0, res = 0;
        for (int i = 0; i < s.size(); i++) {
            int u = getnum(s[i]);
            if (!son[p][u]) return res;
            p = son[p][u];
            res += cnt[p];
        }
        return res;
    }//查询该串的所有前缀个数
};

struct Node {
    int nxt[26];
    i64 v;
    bool isend;
    Node() {
        memset(nxt, -1, sizeof nxt);
        v = isend = 0;
    }
};

struct Trie {
    vector<Node>tr;
    Trie() {
        tr.emplace_back();
    }
    void insert(const string& s, i64 v) {
        int p = 0;
        for (char c : s) {
            int u = c - 'a';
            if (tr[p].nxt[u] == -1) {
                tr[p].nxt[u] = tr.size();
                tr.emplace_back();
            }
            p = tr[p].nxt[u];
            tr[p].v += v;
        }
        tr[p].isend = true;
    }
    i64 work(const string& s) {
        int p = 0;
        for (auto c : s) {
            int u = c - 'a';
            if (tr[p].nxt[u] == -1) {
                return 0;
            }
            p = tr[p].nxt[u];
        }
        return tr[p].v;
    }
};
class trie {
private:
    int B;
    vector<array<int, 2>> S;
    vector<int> cnt;
public:
    trie(int b) : B(b) {
        S.push_back({ -1, -1 });
        cnt.push_back(0);
    }
    void insert(int x) {
        int p = 0;
        cnt[p]++;
        for (int i = B - 1; i >= 0; i--) {
            int b = (x >> i) & 1;
            if (S[p][b] == -1) {
                S[p][b] = S.size();
                S.push_back({ -1, -1 });
                cnt.push_back(0);
            }
            p = S[p][b];
            cnt[p]++;
        }
    }
    void erase(int x) {
        int p = 0;
        cnt[p]--;
        for (int i = B - 1; i >= 0; i--) {
            int b = (x >> i) & 1;
            p = S[p][b];
            cnt[p]--;
        }
    }
    int max_xor(int x) {
        int res = 0;
        int p = 0;
        for (int i = B - 1; i >= 0; i--) {
            int b = (x >> i) & 1;
            int fb = !b;
            if (S[p][fb] != -1 && cnt[S[p][fb]] > 0) {
                res |= (1 << i);
                p = S[p][fb];
            } else {
                p = S[p][b];
            }
        }
        return res;
    }
};
```

#### [2]KMP

```C++
class KMP {
protected:
    int n;
    string p;
    vector<int> next;
public:
    KMP(const string& pattern) { init(pattern); }
    const void init() {
        for (int i = 1, j = -1; i < n; i++) {
            while (j != -1 && p[j + 1] != p[i]) {
                j = next[j];
            }
            if (p[j + 1] == p[i]) {
                j++;
            }
            next[i] = j;
        }
    }
    const void init(const string& pattern) {
        p = std::move(pattern);
        n = p.size();
        next.assign(n, -1);
        init();
    }
    const vector<int> work(const string& s) {
        vector<int> res;
        for (int i = 0, j = -1; i < s.size(); i++) {
            while (j != -1 && p[j + 1] != s[i]) {
                j = next[j];
            }
            if (p[j + 1] == s[i]) {
                j++;
            }
            if (j == n - 1) {
                j = next[j];
                res.push_back(i - n + 1);
            }
        }
        return res;
    }
    const vector<int> getNext() {
        return next;
    }
};
```

#### [3]manacher

```C++
vector<int> manacher(string s) {
    string a = "~";
    for (auto c : s) {
        a += c;
        a += '~';
    }
    int n = a.size();
    vector<int>r(n);
    for (int i = 0, j = 0; i < n; i++) {
        if (2 * j - i >= 0 && j + r[j] > i) {
            r[i] = min(r[2 * j - i], j + r[j] - i);
        }
        while (i - r[i] >= 0 && i + r[i] < n && a[i - r[i]] == a[i + r[i]]) {
            r[i] += 1;
        }
        if (i + r[i] > j + r[j]) {
            j = i;
        }
    }
    return r;
}
//|S*|=2|S|+1,|S奇|=2L-1
```

#### [4]Z函数

```C++
vector<int> z_function(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r && z[i - l] < r - i + 1) {
            z[i] = z[i - l];
        }
        else {
            z[i] = max(0LL, r - i + 1);
            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
        }
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
    z[0] = n;
    return z;
}
```

#### [5]AC自动机

```C++
struct ACAM {
    int n, tot;
    vector<array<int, 26>> tr;
    vector<int> ed, fail, in, deg, cnt;

    ACAM(int n) {
        this->n = n;
        tot = 0;
        tr.assign(n, {});
        ed.assign(n, 0);
        fail.assign(n, 0);
        in.assign(n, 0);
        deg.assign(n, 0);
        cnt.assign(n, 0);
    }

    void add(string s, int id) {
        int p = 0;
        for (char ch : s) {
            int u = ch - 'a';
            if (tr[p][u] == 0) tr[p][u] = ++tot;
            p = tr[p][u];
        }
        ed[p] = id;
        in[id] = p;
    }

    void work() {
        queue<int> q;
        for (int i = 0; i < 26; i++) {
            if (tr[0][i]) q.push(tr[0][i]);
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int i = 0; i < 26; i++) {
                int& x = tr[u][i];
                if (x) {
                    fail[x] = tr[fail[u]][i];
                    deg[tr[fail[u]][i]]++;
                    q.push(x);
                }
                else {
                    x = tr[fail[u]][i];
                }
            }
        }
    }

    vector<int> query(string t, int siz) {
        int p = 0;
        for (char ch : t) {
            int u = ch - 'a';
            p = tr[p][u];
            cnt[p]++;
        }
        queue<int> q;
        for (int i = 1; i <= tot; i++) {
            if (deg[i] == 0) q.push(i);
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();

            int v = fail[u];
            cnt[v] += cnt[u];
            if (--deg[v] == 0) q.push(v);
        }
        vector<int> ans(siz);
        for (int i = 0; i < siz; i++) {
            ans[i] = cnt[in[i]];
        }
        return ans;
    }
};
```

#### [6]哈希其一

```C++
bool isprime(int n) {
    if (n <= 1) {
        return false;
    }
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

int findPrime(int n) {
    while (!isprime(n)) {
        n++;
    }
    return n;
}

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const i64 base = rng();
const i64 P1 = findPrime(rng() % 900000000 + 100000000), P2 = findPrime(rng() % 900000000 + 100000000);

struct H {
    int n;
    i64 ha, p;
    vector<i64>pre, suf, pw;
    H() {}
    H(string& s) {
        n = (int) s.size() - 1;
        pre.resize(n + 5);
        suf.resize(n + 5);
        pw.resize(n + 5);
        pw[0] = { 1 };
        for (int i = 1; i <= n; ++i) {
            pre[i] = (pre[i - 1] * base + s[i] - '0' + 1) % P1;
            pw[i] = pw[i - 1] * base % P1;
        }
        for (int i = n; i >= 1; --i) {
            suf[i] = (suf[i + 1] * base + s[i] - '0' + 1) % P1;
        }
        ha = pre[n];
    }
    H(H& h, int op, int l, int r) {
        n = r - l + 1;
        p = h.pw[r - l + 1];
        if (op == 0) {
            ha = h.pre_hash(l, r);
        }
        else {
            ha = h.suf_hash(l, r);
        }
    }
    i64 pre_hash(int l, int r) {
        i64 h1 = (pre[r] - pre[l - 1] * pw[r - l + 1] % P1 + P1) % P1;
        return h1;
    }
    i64 suf_hash(int l, int r) {
        i64 h1 = (suf[l] - suf[r + 1] * pw[r - l + 1] % P1 + P1) % P1;
        return h1;
    }
    H operator + (H& h)const {
        i64 h1 = (ha * h.p + h.ha) % P1;
        H res;
        res.n = n + h.n;
        res.ha = h1;
        return res;
    }
    bool operator == (H& h)const {
        return n == h.n && ha == h.ha;
    }
    bool is_palindrome(int l, int r) {
        return pre_hash(l, r) == suf_hash(l, r);
    }
    i64 lcp(H& h, int l1, int r1, int l2, int r2) {
        int l = 0, r = r1 - l1 + 2;
        if (r1 - l1 > r2 - l2) {
            l = 0, r = r2 - l2 + 2;
        }
        while (l + 1 < r) {
            int mid = (l + r) >> 1;
            if (pre_hash(l1, l1 + mid - 1) == h.pre_hash(l2, l2 + mid - 1))l = mid;
            else r = mid;
        }
        return l;
    }
};
```

#### [7]哈希其二

```C++
bool isprime(int n) {
    if (n <= 1) {
        return false;
    }
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
int findPrime(int n) {
    while (!isprime(n)) {
        n++;
    }
    return n;
}
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int P1 = findPrime(rng() % 900000000 + 100000000), P2 = findPrime(rng() % 900000000 + 100000000);
const int MAXN = 2e5 + 5;
u64 w[MAXN];
void init_rng(int n) {
    for (int i = 0; i < n; i++) {
        w[i] = rng() * rng() * rng();
    }
}
```



#### [8]后缀数组

```C++
struct SuffixArray {
    int n;
    vector<int> sa, rk, lc;
    SuffixArray(const string& s) {
        n = s.length();
        sa.resize(n);
        lc.resize(n - 1);
        rk.resize(n);
        iota(sa.begin(), sa.end(), 0);
        sort(sa.begin(), sa.end(), [&] (int a, int b) {return s[a] < s[b]; });
        rk[sa[0]] = 0;
        for (int i = 1; i < n; ++i)rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);
        int k = 1;
        vector<int> tmp, cnt(n);
        tmp.reserve(n);
        while (rk[sa[n - 1]] < n - 1) {
            tmp.clear();
            for (int i = 0; i < k; ++i)
                tmp.push_back(n - k + i);
            for (auto i : sa)
                if (i >= k)
                    tmp.push_back(i - k);
            fill(cnt.begin(), cnt.end(), 0);
            for (int i = 0; i < n; ++i)
                ++cnt[rk[i]];
            for (int i = 1; i < n; ++i)
                cnt[i] += cnt[i - 1];
            for (int i = n - 1; i >= 0; --i)
                sa[--cnt[rk[tmp[i]]]] = tmp[i];
            swap(rk, tmp);
            rk[sa[0]] = 0;
            for (int i = 1; i < n; ++i)
                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);
            k *= 2;
        }
        for (int i = 0, j = 0; i < n; ++i) {
            if (rk[i] == 0) {
                j = 0;
            } else {
                for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j]; )
                    ++j;
                lc[rk[i] - 1] = j;
            }
        }
    }
};
```

#### [9]回文自动机PAM

```C++
struct PAM {
    static const int ALPHABET_SIZE = 26;
    struct Node {
        int len;
        int link;
        int cnt;
        array<int, ALPHABET_SIZE> next;
        Node() : len{}, link{}, cnt{}, next{} {}
    };
    vector<Node> t;
    int suff;
    string s;
    PAM() {
        init();
    }
    void init() {
        t.assign(2, Node());
        t[0].len = -1;
        suff = 1;
        s.clear();
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    bool add(char c) {
        int pos = s.size();
        s += c;
        int let = c - 'a';
        int cur = suff, curlen = 0;
        while (true) {
            curlen = t[cur].len;
            if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos]) {
                break;
            }
            cur = t[cur].link;
        }
        if (t[cur].next[let]) {
            suff = t[cur].next[let];
            return false;
        }
        int num = newNode();
        suff = num;
        t[num].len = t[cur].len + 2;
        t[cur].next[let] = num;
        if (t[num].len == 1) {
            t[num].link = 1;
            t[num].cnt = 1;
            return true;
        }
        while (true) {
            cur = t[cur].link;
            curlen = t[cur].len;
            if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos]) {
                t[num].link = t[cur].next[let];
                break;
            }
        }
        t[num].cnt = 1 + t[t[num].link].cnt;
        return true;
    }
    int next(int p, int x) {
        return t[p].next[x];
    }
    int link(int p) {
        return t[p].link;
    }
    int len(int p) {
        return t[p].len;
    }
    int size() {
        return t.size();
    }
};
```

#### [10]最小表示法

```c++
template <typename Iterator>
int minrotation(Iterator first, Iterator last) {
    int length = last - first;
    auto normed = [length] (int a) -> int { return a >= length ? a - length : a; };
    int i = 0, j = 1;
    while (j < length) {
        int same = 0;
        while (same < length && *(first + normed(i + same)) == *(first + normed(j + same))) same++;
        if (same == length) break;
        if (*(first + normed(i + same)) > *(first + normed(j + same)))
            i += same + 1;
        else
            j += same + 1;
        if (i == j)
            j++;
        else if (i > j)
            swap(i, j);
    }
    return i;
}
```



# 数学

#### [1]线性筛

```C++
const int N = 1e7 + 5;
//p表示筛去该数的最小质数，pr存质数，phi为欧拉函数，mu为莫比乌斯函数
int p[N], pr[N], phi[N], mu[N], mi[N], tot;
i64 dcnt[N], dsum[N];
void Sieve(int n) {
    phi[1] = mu[1] = dcnt[1] = dsum[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!p[i])p[i] = i, pr[++tot] = i, phi[i] = i - 1, mu[i] = -1, dcnt[i] = 2, mi[i] = 1, dsum[i] = i + 1;
        for (int j = 1; j <= tot && pr[j] * i <= n; j++) {
            p[i * pr[j]] = pr[j];
            if (i % pr[j] == 0) {
                phi[i * pr[j]] = pr[j] * phi[i];
                mu[i * pr[j]] = 0;
                dcnt[i * pr[j]] = dcnt[i] / (mi[i] + 1) * (mi[i] + 2);
                mi[i * pr[j]] = mi[i] + 1;
                dsum[i * pr[j]] = dsum[i] + (dsum[i] - dsum[i / pr[j]]) * pr[j];
                break;
            }
            else {
                phi[i * pr[j]] = phi[i] * (pr[j] - 1);
                mu[i * pr[j]] = -mu[i];
                dcnt[i * pr[j]] = dcnt[i] * dcnt[pr[j]];
                mi[i * pr[j]] = 1;
                dsum[i * pr[j]] = dsum[i] + dsum[i] * pr[j];
            }
        }
    }
}
```

#### [2]组合数学

```C++
const int N = 2e6 + 5;
Z fac[N]{ 1 };
Z invfac[N];
Z Cat[N]{ 1,1 };
Z wa[N]{ 1,0,1 };
Z __C[N][N], __Cat[N]{ 1,1 };

struct Comb {
    Comb() {
        for (int i = 1; i <= N - 5; i++)fac[i] = fac[i - 1] * i;
        invfac[N - 5] = ~fac[N - 5];
        for (int i = N - 6; i >= 0; i--)invfac[i] = invfac[i + 1] * (i + 1);
        for (int i = 2; i <= N - 5; i++)Cat[i] = Cat[i - 1] * (4 * i - 2) / (i + 1);
        for (int i = 3; i <= N - 5; i++)wa[i] = ((wa[i - 1] + wa[i - 2])) * (i - 1);

        __C[0][0] = 1;
        for (int i = 1; i <= N - 5; i++) {
            for (int j = 0; j <= N - 5; j++) {
                if (j)__C[i][j] = __C[i - 1][j - 1] + __C[i][j];
                __C[i][j] = __C[i][j] + __C[i - 1][j];
            }
        }
        for (int i = 2; i <= N - 5; i++) {
            for (int j = 0; j <= i - 1; j++) {
                __Cat[i] = __Cat[i] + __Cat[j] * __Cat[i - j - 1];
            }
        }
    }
}_;

Z _C(i64 n, i64 m) {
    if (m > n)return 0;
    return fac[n] * invfac[m] * invfac[n - m];
}

Z C(i64 n, i64 m) {
    if (m > n)return 0;
    return fac[n] / fac[m] / fac[n - m];
}

Z A(i64 n, i64 m) {
    if (m > n)return 0;
    return fac[n] / fac[n - m];
}

namespace COUNT {
    const int maxn = 2e6 + 5;
    const int p = 998244353;
    i64 fac[maxn]{ 1 };
    i64 Cat[maxn]{ 1,1 };
    i64 wa[maxn]{ 1,0,1 };
    i64 quick(i64 a, i64 n) {
        i64 res = 1;
        while (n) {
            if (n & 1) res = res * a % p;
            a = a * a % p;
            n >>= 1;
        }
        return res;
    }
    i64 inv(i64 a) { return quick(a, p - 2); }
    i64 C(i64 n, i64 m) {
        if (m > n)return 0;
        return fac[n] * inv(fac[m]) % p * inv(fac[n - m]) % p;
    }
    i64 Lucas(i64 n, i64 m) {
        if (m == 0)return 1;
        return C(n % p, m % p) * Lucas(n / p, m / p) % p;
    }
    void init(int _n) {
        for (int i = 1; i <= _n; i++)fac[i] = fac[i - 1] * i % p;
        for (int i = 2; i <= _n; i++)Cat[i] = Cat[i - 1] * (4 * i - 2) % p * inv(i + 1) % p;
        for (int i = 3; i <= _n; i++)wa[i] = (i - 1) * ((wa[i - 1] + wa[i - 2]) % p) % p;
    }
}
using namespace COUNT;
//S(n, m) = S(n−1, m−1) + m * S(n−1, m), 其中 S(1, 1) = 1 

//不要求逆元存在 复杂度O(n*n)
const int N = 2025;
const int mod = 2023;

i64 C[N][N], Cat[N]{ 1,1 };

void init() {
    C[0][0] = 1;
    for (int i = 1; i <= N - 1; i++) {
        for (int j = 0; j <= N - 1; j++) {
            if (j)C[i][j] = (C[i - 1][j - 1] + C[i][j]) % mod;
            C[i][j] = (C[i][j] + C[i - 1][j]) % mod;
        }
    }
    for (int i = 2; i <= N - 1; i++) {
        for (int j = 0; j <= i - 1; j++) {
            Cat[i] = (Cat[i] + Cat[j] * Cat[i - j - 1] % mod) % mod;
        }
    }
}

1.n个不同的物品放入m个不同的盒子里的方案数(盒子允许为空)


2.n个不同的物品放入m个不同的盒子里的方案数(盒子不允许为空)


3.n个相同的物品放入m个不同的盒子里的方案数(盒子允许为空) == x1 + x2 + ... + xm = n不定方程非负整数解个数


4.n个相同的物品放入m个不同的盒子里的方案数(盒子不允许为空) == x1 + x2 + ... + xm = n不定方程正整数解个数


5.n个相同的物品放入m个相同的盒子里的方案数(盒子不允许为空) == 有0的整数分拆


6.n个相同的物品放入m个相同的盒子里的方案数(盒子允许为空) == 有1的整数分拆


7.n个不同的物品放入m个相同的盒子里的方案数(盒子允许为空)


8.n个不同的物品放入m个相同的盒子里的方案数(盒子不允许为空) == n个整体划分为m个子集

/*
1.n^m

2.m!S(n,m)

3.C(n+m-1,m-1)

4.C(n-1,m-1)

5.dfs

6.dfs

7.(i=1->m)ΣS(n,i)

8.S(n,m)

*/
```

#### [3]快速幂

```C++
const int P = 1e9 + 7;
i64 quick(i64 a, i64 n) {
    i64 res = 1;
    while (n) {
        if (n & 1) res = res * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return res;
}
```

#### [4]等差/等比数列

```C++
 auto qsum = [&] (i64 a1, int q, int n) ->i64 {
        return a1 * (quick(q, n) - 1) % MD * inv(q - 1) % MD;
    };

    auto dsum = [&] (i64 a1, i64 d, i64 n)->i64 {
        i64 an = a1 + (n - 1) * d;
        return (a1 + an) * n / 2;
    };
```

#### [5]log求欧拉函数

```C++
int phi(int x) {
    int res = x, a = x;
    for (int i = 2; i * i <= a; i++) {
        if (a % i == 0) {
            res = res / i * (i - 1);
            while (a % i == 0) a = a / i;
        }
    }
    if (a > 1) res = res / a * (a - 1);
    return res;
}
```

#### [6]中国剩余定理EXCRT

```C++
i128 exgcd(i128 a, i128 b, i128& x, i128& y) {
    if (b == 0) { x = 1, y = 0; return  a; }
    i128 d, x1, y1;
    d = exgcd(b, a % b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return d;
}

i128 excrt(int n, int m[], int r[]) {
    i128 m1, m2, r1, r2, p, q;
    m1 = m[1], r1 = r[1];
    for (int i = 2; i <= n; i++) {
        m2 = m[i], r2 = r[i];
        i128 d = exgcd(m1, m2, p, q);
        if ((r2 - r1) % d) { return -1; }
        p = p * (r2 - r1) / d;
        p = (p % (m2 / d) + m2 / d) % (m2 / d);
        r1 = m1 * p + r1;
        m1 = m1 * m2 / d;
    }
    return r1;
}
```

#### [7]整除分块

```C++
//n
//∑ f(i) * g(⌊m/(ai+b)⌋)    //f函数写的时候写的是i的积分式  //如果有多个g函数，实现里面也乘多个g就行了。
//i=s
i64 cal(int s, int n, int m, const function<i64(int)>& f = {}, const function<i64(int)>& g = {}, int a = 1, int b = 0) {
    i64 res = 0;
    for (int l = s, r; l <= min(n, m); l = r + 1) {
        int v = m / (a * l + b);
        r = min(n, m / (v - b) / a);
        res += 1LL * (g ? g(v) : v) * (f ? (f(r) - f(l - 1)) : (r - l + 1));
    }
    return res;
}

//n
//∑ f(i) * g(⌈m/(ai+b)⌉)    //f函数写的时候写的是i的积分式  //如果有多个g函数，实现里面也乘多个g就行了。
//i=s
i64 cal(int s, int n, int m, const function<i64(int)>& f = {}, const function<i64(int)>& g = {}) {
    i64 res = 0;
    for (int l = s, r; l <= min(n, m); l = r + 1) {
        int v = (m + l - 1) / l;
        r = min(n, (m - 1) / (v - 1));
        res += 1LL * (g ? g(v) : v) * (f ? (f(r) - f(l - 1)) : (r - l + 1));
    }
    return res;
}
```

#### [8]矩阵

```C++
constexpr int M = 2;
struct Mat :array<array<Z, M + 1>, M + 1>{
    Mat(Z x = 0) {
        this->fill({});
        for (int i = 1; i <= M; i++) {
            for (int j = 1; j <= M; j++) {
                (*this)[i][j] = (i == j) ? Z(x) : Z(0);
            }
        }
    }
    Mat operator*(const Mat& t) const {
        Mat b;
        for (int i = 1; i <= M; i++)
            for (int j = 1; j <= M; j++) {
                Z sum = 0;
                for (int k = 1; k <= M; k++)
                    sum += (*this)[i][k] * t[k][j];
                b[i][j] = sum;
            }
        return b;
    }
    Mat operator*=(const Mat b) {
        return *this = *this * b;
    }
    Mat operator^(i64 k)const {
        assert(k >= 0);
        Mat t = (*this), ans = (*this);
        if (k == 0) {
            return Mat(1);
        }
        for (k--; k; k >>= 1, t = t * t)
            if (k & 1)ans = ans * t;
        return ans;
    }
};
```

#### [9]分解质因数

```c++
vector<i64>factor(i64 x) {
    vector<i64>res{ 1,x };
    for (i64 i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            res.emplace_back(i);
            if (x / i != i) {
                res.emplace_back(x / i);
            }
        }
    }
    return res;
};

vector<pair<i64, int>>factor(i64 n) {
    vector<pair<i64, int>> f;
    for (i64 i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            int c = 0;
            while (n % i == 0) {
                n /= i;
                c++;
            }
            f.emplace_back(i, c);
        }
    }
    if (n > 1) {
        f.emplace_back(n, 1);
    }
    return f;
}
```



# 图论

#### [1]SCC

```C++
struct SCC {
    int n;
    vector<vector<int>> adj;
    vector<int> dfn, low, col, S, nw, w;
    int now, cnt;
    SCC(int n) : n(n) {
        init(n);
    }
    void init(int n) {
        adj.assign(n + 1, {});
        dfn.resize(n + 1, -1);
        low.resize(n + 1);
        w.resize(n + 1);
        nw.resize(n + 1);
        col.assign(n + 1, -1);
        S.clear();
        now = cnt = 0;
    }
    void add(int x, int y) {
        adj[x].push_back(y);
    }
    void addw(int i, int x) {
        w[i] = x;
    }
    void tarjan(int x) {
        dfn[x] = low[x] = ++now;
        S.push_back(x);
        for (auto y : adj[x]) {
            if (dfn[y] == -1) {
                tarjan(y);
                low[x] = min(low[x], low[y]);
            }
            else if (col[y] == -1) {
                low[x] = min(low[x], dfn[y]);
            }
        }
        if (dfn[x] == low[x]) {
            int pre;
            cnt++;
            do {
                pre = S.back();
                col[pre] = cnt;
                nw[cnt] += w[pre];
                S.pop_back();
            } while (pre != x);
        }
    }
    pair<int, vector<vector<int>>> rebuild() {
        work();
        vector<vector<int>> ver(cnt + 1);
        for (int i = 1; i <= n; i++) {
            for (auto j : adj[i]) {
                int x = col[i], y = col[j];
                if (x != y) {
                    ver[x].push_back(y);
                }
            }
        }
        return { cnt, ver };
    }
    void work() {
        for (int i = 1; i <= n; i++) {
            if (dfn[i] == -1) {
                tarjan(i);
            }
        }
    }
};
//所有的tarjan 都不要多创建，是n就创建n大小，否则会有空点
```



#### [2]EDCC

```C++
struct EDCC {
    int n;
    vector<int> h, ver, ne;
    vector<int> dfn, low, col, S, ct;
    int now, cnt, tot;
    vector<bool> bridge;
    EDCC(int n, int m) : n(n) {
        m *= 2;
        ver.resize(m + 1);
        ne.resize(m + 1);
        bridge.resize(m + 1);
        h.resize(n + 1, -1);
        dfn.resize(n + 1);
        low.resize(n + 1);
        col.resize(n + 1);
        S.clear();
        ct.clear();
        ct.push_back(0);
        tot = cnt = now = 0;
    }
    void add(int x, int y) {
        ver[tot] = y, ne[tot] = h[x], h[x] = tot++;
        ver[tot] = x, ne[tot] = h[y], h[y] = tot++;
    }
    void tarjan(int x, int fa) {
        dfn[x] = low[x] = ++now;
        S.push_back(x); ct.push_back(0);
        for (int i = h[x]; ~i; i = ne[i]) {
            int y = ver[i];
            if (!dfn[y]) {
                tarjan(y, i);
                low[x] = min(low[x], low[y]);
                if (dfn[x] < low[y]) {
                    bridge[i] = bridge[i ^ 1] = true;
                }
            }
            else if (i != (fa ^ 1)) {
                low[x] = min(low[x], dfn[y]);
            }
        }
        if (dfn[x] == low[x]) {
            int pre = 0;
            cnt++;
            do {
                pre = S.back();
                S.pop_back();
                ct[cnt]++;
                col[pre] = cnt;
            } while (pre != x);
        }
    }
    pair<int, vector<vector<int>>> rebuild() {
        work();
        vector<vector<int>> adj(cnt + 1);
        for (int i = 0; i < tot; ++i) {
            if (bridge[i]) {
                int x = col[ver[i]], y = col[ver[i ^ 1]];
                adj[x].push_back(y);
            }
        }
        return { cnt, adj };
    }
    void work() {
        for (int i = 1; i <= n; i++) {
            if (dfn[i] == 0) {
                tarjan(i, -1);
            }
        }
    }
};
```



#### [3]VDCC

```C++
struct VDCC {
    int n;
    vector<vector<int>> ver, vDCC;
    vector<int> dfn, low, newId, belong;
    stack<int> S;
    int now, cnt;
    vector<bool> point;
    VDCC(int n) : n(n) {
        init(n);
    }
    void init(int n) {
        ver.resize(n + 1);
        dfn.resize(n + 1);
        low.resize(n + 1);
        newId.resize(n + 1);
        point.resize(n + 1);
        belong.resize(n + 1);
        vDCC.resize(2 * n + 1);
        while (S.size())S.pop();
        cnt = now = 0;
    }
    void add(int x, int y) {
        if (x == y) return;
        ver[x].push_back(y);
        ver[y].push_back(x);
    }
    void tarjan(int x, int root) {
        low[x] = dfn[x] = ++now;
        S.push(x);
        if (x == root && !ver[x].size()) {
            cnt++;
            vDCC[cnt].push_back(x);
            return;
        }
        int flag = 0;
        for (auto y : ver[x]) {
            if (!dfn[y]) {
                tarjan(y, root);
                low[x] = min(low[x], low[y]);
                if (dfn[x] <= low[y]) {
                    flag++;
                    if (x != root || flag > 1) {
                        point[x] = true;
                    }
                    int pre = 0;
                    cnt++;
                    do {
                        pre = S.top();
                        vDCC[cnt].push_back(pre);
                        S.pop();
                    } while (pre != y);
                    vDCC[cnt].push_back(x);
                }
            }
            else {
                low[x] = min(low[x], dfn[y]);
            }
        }
    }
    pair<int, vector<vector<int>>> rebuild() {
        work();
        int tmp = cnt;
        for (int i = 1; i <= n; i++)
            if (point[i])
                newId[i] = ++tmp;
        vector<vector<int>> adj(cnt + 1);
        for (int i = 1; i <= cnt; i++) {
            for (auto v : vDCC[i]) {
                if (point[v]) {
                    adj.push_back({ i, newId[v] });
                    adj.push_back({ newId[v],i });
                }
                else belong[v] = i;
            }
        }
        return { cnt, adj };
    }
    void work() {
        for (int i = 1; i <= n; i++) {
            if (!dfn[i]) {
                tarjan(i, i);
            }
        }
    }
};
```



#### [4]欧拉路径

```C++
 int cnt = 0;
    vector<vector<pair<int, int>>>g(501);
    vector<int>dg(501);
    int dsa = inf;
    for (int i = 1; i <= n; i++) {
        int u, v;
        cin >> u >> v;
        dsa = min({ dsa, u, v });
        g[u].push_back({ v,++cnt });
        g[v].push_back({ u,cnt });
        dg[u]++;
        dg[v]++;
    }

    int cnt1 = 0, cnt2 = 0, s = inf;
    for (int i = 1; i <= 500; i++) {
        sort(g[i].begin(), g[i].end(), greater<>());
        if (dg[i] & 1)cnt1++, s = min(s, i);
        else cnt2++;
    }
    if (s == inf)s = dsa;

    vector<int>ans, vis(n * 2 + 1);
    auto dfs = [&] (auto self, int x)->void {
        while (g[x].size()) {
            pair<int, int>t = g[x].back();
            g[x].pop_back();
            if (vis[t.second])continue;
            vis[t.second] = 1;
            self(self, t.first);
        }
        ans.push_back(x);
    };

    dfs(dfs, s);
    for (int i = ans.size() - 1; i >= 0; i--) {
        cout << ans[i] << "\n";
    }
```

#### [5]dij

```C++
vector<i64> dij(vector<vector<pair<int, int>>>& g, int s, bool MAX = 0) {
    int n = (int)g.size() - 1;
    vector<i64>dis(n + 1, INF);
    vector<int>vis(n + 1, 0);
    priority_queue<pair<i64, int>, vector<pair<i64, int>>, greater<pair<i64, int>>>pq;
    dis[s] = 0;
    pq.push({ 0,s });
    while (pq.size()) {
        int x = pq.top().second;
        pq.pop();
        if (vis[x])continue;
        vis[x] = 1;

        auto f = [&] (i64 x, i64 y) {
            if (MAX)return max(x, y);
            return x + y;
        };

        for (auto [y, v] : g[x]) {
            if (vis[y] || f(dis[x], v) >= dis[y]) continue;
            dis[y] = f(dis[x], v);
            pq.push({ dis[y],y });
        }
    }
    return dis;
}
```

#### [6]spfa

```C++
 struct node {
        int e, v;
    };
    vector<vector<node>>g(n + 1);
    vector<int>dis(n + 1), cnt(n + 1), vis(n + 1);
    auto spfa = [&] (int s) -> bool {
        queue<int>q;
        dis.assign(n + 1, inf);
        cnt.assign(n + 1, 0);
        vis.assign(n + 1, 0);
        dis[s] = 0, vis[s] = 1;
        q.push(s);
        while (q.size()) {
            int u = q.front();
            q.pop();
            vis[u] = 0;
            for (auto [e, v] : g[u]) {
                if (dis[e] > dis[u] + v) {
                    dis[e] = dis[u] + v;
                    cnt[e] = cnt[u] + 1;
                    if (cnt[e] >= n)return 1;//如果有虚点0，则改成>n
                    if (!vis[e])q.push(e), vis[e] = 1;
                }
            }
        }
        return 0;
    };
```



#### [7]floyd

```C++
int _n = c;
    vector<vector<int>>dis(_n + 1, vector<int>(_n + 1));
    for (int i = 1; i <= _n; i++) {
        for (int j = 1; j <= _n; j++) {
            if (i == j)continue;
            dis[i][j] = dis[j][i] = inf;
        }
    }
    for (int i = 1; i <= m; i++) {
        int a, b, d;
        cin >> a >> b >> d;
        dis[a][b] = dis[b][a] = d;
    }
    for (int k = 1; k <= _n; k++) {
        for (int i = 1; i <= _n; i++) {
            for (int j = 1; j <= _n; j++) {
                if (dis[i][j] > dis[i][k] + dis[k][j]) {
                    dis[i][j] = dis[j][i] = dis[i][k] + dis[k][j];
                }
            }
        }
    }
```



#### [8] topsort

```C++
  vector<vector<int>>g(n + 1);
    vector<int>tp, in(n + 1);
    queue<int>q;
    auto topsort = [&] (int n)->bool {
        while (!q.empty())q.pop();
        for (int i = 1; i <= n; i++) {
            if (in[i] == 0)q.push(i);
        }
        while (q.size()) {
            int x = q.front();
            q.pop();
            tp.push_back(x);
            for (auto y : ve[x]) {
                if (--in[y] == 0)q.push(y);
            }
        }
        return tp.size() == n;
    };
```



#### [9]圆方树

````C++

````

#### [10]最大流最小割

```C++

```



#### [11]费用流

```C++

```

#### [12]生成树

```C++
struct E {
    int s, e, v;
    bool operator <(const E& o)const {
        return v < o.v;
    }
};

struct DSU {
    vector<int> fa, siz;
    DSU() {}
    DSU(int n) { init(n); }
    void init(int n) {
        fa.resize(n);
        iota(fa.begin(), fa.end(), 0);
        siz.assign(n, 1);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    bool merge(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        fa[y] = x;
        return true;
    }
    bool Heuristic_merge(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) {
            return false;
        }
        if (siz[x] < siz[y]) swap(x, y);
        siz[x] += siz[y];
        fa[y] = x;
        return true;
    }
    int size(int x) {
        return siz[find(x)];
    }
};

pair<vector<vector<int>>, i64> kruskal(vector<E>& edge, int n) {
    sort(edge.begin(), edge.end());
    DSU dsu(n + 1);
    i64 cost = 0;
    int cnt = n;
    vector<vector<int>>S(n + 1);
    for (auto [s, e, v] : edge) {
        if (dsu.merge(s, e)) {
            cost += v;
            S[s].push_back(e);
            S[e].push_back(s);
            cnt--;
            if (cnt == 1)break;
        }
    }
    if (cnt != 1)cost = INF;
    return { S,cost };
}
=============================
struct node {
    int e, v;
};

pair<vector<array<i64, 3>>, i64>prim(vector<vector<node>>& g) {
    using PII = pair<i64, int>;
    priority_queue<PII>pq;
    vector<i64>dis(g.size(), INF);
    vector<int>vis(g.size());
    vector<int>pre(g.size());
    dis[1] = 0;
    pq.push({ 0,1 });
    i64 cost = 0;
    vector<array<i64, 3>>e;
    while (pq.size()) {
        auto [y, x] = pq.top();
        pq.pop();
        if (vis[x]) continue;
        vis[x] = 1;
        cost -= y;
        if (pre[x]) {
            e.push_back({ x,pre[x],-y });
        }
        for (auto i : g[x]) {
            if (dis[i.e] > i.v) {
                dis[i.e] = i.v;
                pre[i.e] = x;
                if (!vis[i.e]) {
                    pq.push({ -dis[i.e],i.e });
                }
            }
        }
    }
    for (int i = 1; i < g.size(); i++) {
        if (!vis[i]) {
            cost = INF;
            break;
        }
    }
    return { e,cost };
}
```





# 树上问题

#### [1]树论

```C++
struct Edge {
    int to;
    i64 w;
};

struct Tree {
public:
    int n;
    vector<vector<Edge>> adj;
    vector<i64> W;
    Tree(int n) : n(n) {
        adj.resize(n + 1);
        W.assign(n + 1, 1);
    }
    void addEdge(int u, int v, i64 w = 1) {
        adj[u].push_back({ v, w });
        adj[v].push_back({ u, w });
    }
    void setNode(int u, i64 w) {
        W[u] = w;
    }
    i64 getEDia() {
        int s = dfsEdge(1, -1).first;
        return dfsEdge(s, -1).second;
    }
    i64 getVDia() {
        Dia = -INF;
        dfsVertex(1, -1);
        return Dia;
    }
    pair<int, int> findG() {
        sub.assign(n + 1, 0);
        bestVal = INF;
        G1 = 0;
        G2 = -1;
        i64 total = 0;
        for (int i = 1; i <= n; i++) {
            total += W[i];
        }
        dfsCentroid(1, -1, total);
        return { G1, G2 };
    }
private:
    pair<int, i64> dfsEdge(int u, int parent) {
        pair<int, i64> res = { u, 0 };
        for (auto& edge : adj[u]) {
            int v = edge.to;
            i64 w = edge.w;
            if (v == parent) continue;
            auto sub = dfsEdge(v, u);
            sub.second += w;
            if (sub.second > res.second) {
                res = sub;
            }
        }
        return res;
    }

    i64 Dia = 0;
    i64 dfsVertex(int u, int parent) {
        i64 max1 = 0, max2 = 0;
        for (auto& edge : adj[u]) {
            int v = edge.to;
            if (v == parent) continue;
            i64 ca = dfsVertex(v, u);
            if (ca > max1) {
                max2 = max1;
                max1 = ca;
            } else if (ca > max2) {
                max2 = ca;
            }
        }
        Dia = max(Dia, W[u] + max1 + max2);
        return W[u] + max1;
    }
    int G1, G2;
    vector<i64> sub;
    i64 bestVal;
    void dfsCentroid(int u, int parent, i64 total) {
        sub[u] = W[u];
        i64 maxSub = 0;
        for (auto& edge : adj[u]) {
            int v = edge.to;
            if (v == parent) continue;
            dfsCentroid(v, u, total);
            sub[u] += sub[v];
            maxSub = max(maxSub, sub[v]);
        }
        maxSub = max(maxSub, total - sub[u]);
        if (maxSub < bestVal) {
            bestVal = maxSub;
            G1 = u;
            G2 = -1;
        } else if (maxSub == bestVal && u != G1) {
            G2 = u;
        }
    }
};

```

#### [2]树链剖分其一

```C++
struct HLD {
    int n;
    vector<int> siz, top, dep, parent, in, out, seq;
    vector<vector<int>> adj;
    int cnt;

    HLD() : n(0), cnt(0) {}
    HLD(int n) {
        init(n);
    }

    void init(int nodes) {
        n = nodes;
        siz.assign(n + 1, 0);
        top.assign(n + 1, 0);
        dep.assign(n + 1, 0);
        parent.assign(n + 1, -1);
        in.assign(n + 1, 0);
        out.assign(n + 1, 0);
        seq.assign(n + 1, 0);
        adj.assign(n + 1, vector<int>());
        cnt = 0;
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    void work(int root = 1) {
        top[root] = root;
        dep[root] = 1;
        parent[root] = -1;
        dfs1(root);
        dfs2(root);
    }

    void dfs1(int u) {
        if (parent[u] != -1) {
            adj[u].erase(find(adj[u].begin(), adj[u].end(), parent[u]));
        }

        siz[u] = 1;
        for (auto& v : adj[u]) {
            parent[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v);
            siz[u] += siz[v];
            if (siz[v] > siz[adj[u][0]]) {
                swap(v, adj[u][0]);
            }
        }
    }
    void dfs2(int u) {
        in[u] = ++cnt;
        seq[in[u]] = u;
        for (auto v : adj[u]) {
            top[v] = v == adj[u][0] ? top[u] : v;
            dfs2(v);
        }
        out[u] = cnt;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = parent[top[u]];
            } else {
                v = parent[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    int dist(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }
    bool in_subtree(int u, int v) {
        return in[v] <= in[u] && in[u] <= out[v];
    }
    int jump(int u, int k) {
        if (dep[u] < k) {
            return -1;
        }
        int d = dep[u] - k;
        while (dep[top[u]] > d) {
            u = parent[top[u]];
        }
        return seq[in[u] - dep[u] + d];
    }
    int rooted_lca(int a, int b, int c) {
        return lca(a, b) ^ lca(b, c) ^ lca(c, a);
    }
    template<typename Q>
    void modify_path(int u, int v, const Q& q, bool edge = false) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            q(in[top[u]], in[u]);
            u = parent[top[u]];
        }
        if (dep[u] > dep[v]) swap(u, v);
        q(in[u] + edge, in[v]);
    }
    template<typename Q>
    void modify_subtree(int u, const Q& q) {
        q(in[u], out[u]);
    }
    template<typename T, typename Q>
    T query_path(int u, int v, const Q& q, bool edge = false) {
        T ret = T();
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            ret = q(in[top[u]], in[u]) + ret;
            u = parent[top[u]];
        }
        if (dep[u] > dep[v]) swap(u, v);
        return q(in[u] + edge, in[v]) + ret;
    }
    template<typename T, typename Q>
    T query_subtree(int u, const Q& q) {
        return q(in[u], out[u]);
    }
    template<typename T, typename Q, typename F>//q是写一个查询函数，参数为(L,R) SWAP是节点是否需要交换 参数为(INFO a INFO b)
    T query_path_noncommutative(int u, int v, const Q& q, const F& SWAP, bool edge = false) {
        T left = T(), right = T();
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) swap(u, v), swap(left, right);
            left = q(in[top[u]], in[u]) + left;
            u = parent[top[u]];
        }
        if (dep[u] > dep[v]) swap(u, v), swap(left, right);
        return SWAP(left, q(in[u] + edge, in[v]) + right);
    }
};
```

#### [3]树链剖分其二

```C++
struct HLD {
    int n;
    vector<int> siz, top, dep, parent, in, out, seq;
    vector<vector<int>> adj;
    int cnt;

    HLD() {}
    HLD(int n) {
        init(n);
    }
    void init(int n) {
        this->n = n;
        siz.resize(n + 1);
        top.resize(n + 1);
        dep.resize(n + 1);
        parent.resize(n + 1);
        in.resize(n + 1);
        out.resize(n + 1);
        seq.resize(n + 1);
        cnt = 0;
        adj.assign(n + 1, {});
    }
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    void work(int root = 1) {
        top[root] = root;
        dep[root] = 1;
        parent[root] = -1;
        dfs1(root);
        dfs2(root);
    }
    void dfs1(int u) {
        if (parent[u] != -1) {
            adj[u].erase(find(adj[u].begin(), adj[u].end(), parent[u]));
        }

        siz[u] = 1;
        for (auto& v : adj[u]) {
            parent[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v);
            siz[u] += siz[v];
            if (siz[v] > siz[adj[u][0]]) {
                swap(v, adj[u][0]);
            }
        }
    }
    void dfs2(int u) {
        in[u] = cnt++;
        seq[in[u]] = u;
        for (auto v : adj[u]) {
            top[v] = v == adj[u][0] ? top[u] : v;
            dfs2(v);
        }
        out[u] = cnt;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = parent[top[u]];
            } else {
                v = parent[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    int dist(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }
    bool in_subtree(int u, int v) {
        return in[v] <= in[u] && in[u] <= out[v];
    }
    int jump(int u, int k) {
        if (dep[u] < k) {
            return -1;
        }

        int d = dep[u] - k;

        while (dep[top[u]] > d) {
            u = parent[top[u]];
        }

        return seq[in[u] - dep[u] + d];
    }
    int rooted_lca(int a, int b, int c) {
        return lca(a, b) ^ lca(b, c) ^ lca(c, a);
    }
    int rootedParent(int u, int v) {
        swap(u, v);
        if (u == v) {
            return u;
        }
        if (!in_subtree(u, v)) {
            return parent[u];
        }
        auto it = upper_bound(adj[u].begin(), adj[u].end(), v, [&] (int x, int y) {
            return in[x] < in[y];
        }) - 1;
        return *it;
    }
    int rootedSize(int u, int v) {
        if (u == v) {
            return n;
        }
        if (!in_subtree(v, u)) {
            return siz[v];
        }
        return n - siz[rootedParent(u, v)];
    }
};
```

#### [4]LCA

```C++
struct LCA {
    vector<vector<int>>g, st;
    vector<int>LOG, dfn;
    int n;
    int f(int x, int y) {
        return dfn[x] < dfn[y] ? x : y;
    }
    LCA(int n) :n(n) {
        g.resize(n + 1);
        dfn.resize(n + 1);
        LOG.resize(n + 1);
        for (int i = 2; i <= n; i++)LOG[i] = LOG[i / 2] + 1;
        st.resize(n + 1, vector<int>(LOG[n] + 1));
    }
    void addEdge(int u, int v) {
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    void work(int rt = 1) {
        int cur = 0;
        auto dfs = [&] (auto self, int x, int fa)->void {
            dfn[x] = ++cur;
            st[dfn[x]][0] = fa;
            for (auto y : g[x]) {
                if (y == fa)continue;
                self(self, y, x);
            }
        };
        dfs(dfs, rt, 0);
        for (int j = 1; 1 << j <= n; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                st[i][j] = f(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
            }
        }
    }
    int operator()(int u, int v) {
        if (u == v)return u;
        if (dfn[u] > dfn[v])swap(u, v);
        int L = dfn[u] + 1, R = dfn[v];
        int j = LOG[R - L + 1];
        return f(st[L][j], st[R - (1 << j) + 1][j]);
    }
};
```

#### [4]点分治

```C++
int has[10000000 + 10];
vector<int> in_has;

struct DFZ {
    vector<vector<pair<int, int>>> g;
    vector<int> vis, size, len, ans;
    int n, m;

    DFZ(int _n, int _m) : n(_n), m(_m) {
        g.resize(n + 1);
        vis.resize(n + 1, 0);
        size.resize(n + 1, 0);
        len.resize(n + 1, 0);
        ans.resize(m + 1, 0);
    }

    void add(int u, int v, int w) {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }

    void get_size(int pos, int fa) {
        size[pos] = 1;
        for (auto& [v, w] : g[pos]) {
            if (v == fa || vis[v]) continue;
            get_size(v, pos);
            size[pos] += size[v];
        }
    }

    int get_center(int pos, int fa, int root) {
        int weight = size[root] - size[pos];
        int center = -1;
        for (auto& [v, w] : g[pos]) {
            if (v == fa || vis[v]) continue;
            weight = max(weight, size[v]);
            center = max(get_center(v, pos, root), center);
        }
        if (weight <= size[root] / 2) center = max(center, pos);
        return center;
    }

    void get_length(int pos, int fa) {
        for (auto& [v, w] : g[pos]) {
            if (v == fa || vis[v]) continue;
            len[v] = len[pos] + w;
            get_length(v, pos);
        }
    }

    void solve(int pos, vector<int> query) {
        // 固定步骤
        // 1. 预处理 size, center
        // 2. 处理以 center 为根的各个子树的 length
        // 3. 枚举 center 的每个儿子, find 然后 add, 避免混淆
        // 4. find 的时候遍历所有询问。

        get_size(pos, -1);
        int center = get_center(pos, -1, pos);
        len[center] = 0;
        get_length(center, -1);

        // find 需要改
        auto find = [&] (auto self, int pos, int fa) -> void {
            for (int i = 1; i <= m; i++) { // 处理 m 个询问
                int it = query[i];
                if (it - len[pos] >= 0 && has[it - len[pos]]) ans[i] = 1;
            }
            for (auto& [v, w] : g[pos]) {
                if (v == fa || vis[v]) continue;
                self(self, v, pos);
            }
        };

        // add 需要改
        auto add = [&] (auto self, int pos, int fa) -> void {
            if (len[pos] <= 10000000) {
                has[len[pos]] = 1;
                in_has.emplace_back(len[pos]);
            }
            for (auto& [v, w] : g[pos]) {
                if (v == fa || vis[v]) continue;
                self(self, v, pos);
            }
        };

        // 桶可能需要改 map
        for (auto& it : in_has) has[it] = 0;
        in_has.clear();

        in_has.emplace_back(0);
        has[0] = 1;

        for (auto& [v, w] : g[center]) {
            if (vis[v]) continue;
            find(find, v, center);
            add(add, v, center);
        }
        vis[center] = 1;
        for (auto& [v, w] : g[center]) {
            if (vis[v]) continue;
            solve(v, query);
        }
    }
};
```



# 杂项

#### [1] i128

```C++
using i128 = __int128;

ostream& operator<<(ostream & os, __int128 t) {
    if (t == 0) return os << "0";
    if (t < 0) {
        os << "-";
        t = -t;
    }
    int a[50], ai = 0;
    memset(a, 0, sizeof a);
    while (t != 0) {
        a[ai++] = t % 10;
        t /= 10;
    }
    for (int i = 1; i <= ai; i++) os << abs(a[ai - i]);
    return os << "";
}

istream& operator>>(istream& is, __int128& t) {
    string s;
    bool f = 0;
    is >> s;
    t = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '-') {
            f = 1;
            continue;
        }
        t *= 10;
        t += s[i] - '0';
    }
    if (f)t = -t;
    return is;
}
```

#### [2]高精度

```C++
struct BI {
    static const int base = 1000000000;
    static const int base_digits = 9;
    vector<int> a;
    int sign;
    BI() : sign(1) {}
    BI operator-() const {
        BI res = *this;
        res.sign = -sign;
        return res;
    }
    BI(long long v) {
        *this = v;
    }
    BI(const string& s) {
        read(s);
    }
    void operator=(const BI& v) {
        sign = v.sign;
        a = v.a;
    }
    void operator=(long long v) {
        a.clear();
        sign = 1;
        if (v < 0) sign = -1, v = -v;
        for (; v > 0; v = v / base) {
            a.push_back(v % base);
        }
    }
    BI operator+(const BI& v) const {
        if (sign == v.sign) {
            BI res = v;
            for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {
                if (i == (int) res.a.size()) {
                    res.a.push_back(0);
                }
                res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);
                carry = res.a[i] >= base;
                if (carry) {
                    res.a[i] -= base;
                }
            }
            return res;
        }
        return *this - (-v);
    }
    BI operator-(const BI& v) const {
        if (sign == v.sign) {
            if (abs() >= v.abs()) {
                BI res = *this;
                for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {
                    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);
                    carry = res.a[i] < 0;
                    if (carry) {
                        res.a[i] += base;
                    }
                }
                res.trim();
                return res;
            }
            return -(v - *this);
        }
        return *this + (-v);
    }
    void operator*=(int v) {
        check(v);
        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {
            if (i == (int) a.size()) {
                a.push_back(0);
            }
            long long cur = a[i] * (long long) v + carry;
            carry = (int) (cur / base);
            a[i] = (int) (cur % base);
        }
        trim();
    }
    void operator/=(int v) {
        check(v);
        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {
            long long cur = a[i] + rem * (long long) base;
            a[i] = (int) (cur / v);
            rem = (int) (cur % v);
        }
        trim();
    }
    int operator%(int v) const {
        if (v < 0) {
            v = -v;
        }
        int m = 0;
        for (int i = a.size() - 1; i >= 0; --i) {
            m = (a[i] + m * (long long) base) % v;
        }
        return m * sign;
    }
    void operator+=(const BI& v) {
        *this = *this + v;
    }
    void operator-=(const BI& v) {
        *this = *this - v;
    }
    BI operator*(int v) const {
        BI res = *this;
        res *= v;
        return res;
    }
    BI operator/(int v) const {
        BI res = *this;
        res /= v;
        return res;
    }
    void operator%=(const int& v) {
        *this = *this % v;
    }

    bool operator<(const BI& v) const {
        if (sign != v.sign) return sign < v.sign;
        if (a.size() != v.a.size()) return a.size() * sign < v.a.size() * v.sign;
        for (int i = a.size() - 1; i >= 0; i--)
            if (a[i] != v.a[i]) return a[i] * sign < v.a[i] * sign;
        return false;
    }
    bool operator>(const BI& v) const {
        return v < *this;
    }
    bool operator<=(const BI& v) const {
        return !(v < *this);
    }
    bool operator>=(const BI& v) const {
        return !(*this < v);
    }
    bool operator==(const BI& v) const {
        return !(*this < v) && !(v < *this);
    }
    bool operator!=(const BI& v) const {
        return *this < v || v < *this;
    }
    BI abs() const {
        BI res = *this;
        res.sign *= res.sign;
        return res;
    }
    void check(int v) {
        if (v < 0) {
            sign = -sign;
            v = -v;
        }
    }
    void trim() {
        while (!a.empty() && !a.back()) a.pop_back();
        if (a.empty()) sign = 1;
    }
    bool isZero() const {
        return a.empty() || (a.size() == 1 && !a[0]);
    }
    friend BI gcd(const BI& a, const BI& b) {
        return b.isZero() ? a : gcd(b, a % b);
    }
    friend BI lcm(const BI& a, const BI& b) {
        return a / gcd(a, b) * b;
    }
    void read(const string& s) {
        sign = 1;
        a.clear();
        int pos = 0;
        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {
            if (s[pos] == '-') sign = -sign;
            ++pos;
        }
        for (int i = s.size() - 1; i >= pos; i -= base_digits) {
            int x = 0;
            for (int j = max(pos, i - base_digits + 1); j <= i; j++) x = x * 10 + s[j] - '0';
            a.push_back(x);
        }
        trim();
    }
    friend istream& operator>>(istream& stream, BI& v) {
        string s;
        stream >> s;
        v.read(s);
        return stream;
    }
    friend ostream& operator<<(ostream& stream, const BI& v) {
        if (v.sign == -1) stream << '-';
        stream << (v.a.empty() ? 0 : v.a.back());
        for (int i = (int) v.a.size() - 2; i >= 0; --i)
            stream << setw(base_digits) << setfill('0') << v.a[i];
        return stream;
    }
    typedef vector<long long> vll;
    BI operator*(const BI& v) const {
        vector<int> a6 = convert_base(this->a, base_digits, 6);
        vector<int> b6 = convert_base(v.a, base_digits, 6);
        vll a(a6.begin(), a6.end());
        vll b(b6.begin(), b6.end());
        while (a.size() < b.size()) a.push_back(0);
        while (b.size() < a.size()) b.push_back(0);
        while (a.size() & (a.size() - 1)) a.push_back(0), b.push_back(0);
        vll c = karatsubaMultiply(a, b);
        BI res;
        res.sign = sign * v.sign;
        for (int i = 0, carry = 0; i < (int) c.size(); i++) {
            long long cur = c[i] + carry;
            res.a.push_back((int) (cur % 1000000));
            carry = (int) (cur / 1000000);
        }
        res.a = convert_base(res.a, 6, base_digits);
        res.trim();
        return res;
    }
    friend pair<BI, BI> divmod(const BI& a1,
        const BI& b1) {
        int norm = base / (b1.a.back() + 1);
        BI a = a1.abs() * norm;
        BI b = b1.abs() * norm;
        BI q, r;
        q.a.resize(a.a.size());
        for (int i = a.a.size() - 1; i >= 0; i--) {
            r *= base;
            r += a.a[i];
            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];
            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];
            int d = ((long long) base * s1 + s2) / b.a.back();
            r -= b * d;
            while (r < 0) r += b, --d;
            q.a[i] = d;
        }
        q.sign = a1.sign * b1.sign;
        r.sign = a1.sign;
        q.trim();
        r.trim();
        return make_pair(q, r / norm);
    }
    static vector<int> convert_base(const vector<int>& a, int old_digits, int new_digits) {
        vector<long long> p(max(old_digits, new_digits) + 1);
        p[0] = 1;
        for (int i = 1; i < (int) p.size(); i++) p[i] = p[i - 1] * 10;
        vector<int> res;
        long long cur = 0;
        int cur_digits = 0;
        for (int i = 0; i < (int) a.size(); i++) {
            cur += a[i] * p[cur_digits];
            cur_digits += old_digits;
            while (cur_digits >= new_digits) {
                res.push_back((int) (cur % p[new_digits]));
                cur /= p[new_digits];
                cur_digits -= new_digits;
            }
        }
        res.push_back((int) cur);
        while (!res.empty() && !res.back()) res.pop_back();
        return res;
    }
    static vll karatsubaMultiply(const vll& a, const vll& b) {
        int n = a.size();
        vll res(n + n);
        if (n <= 32) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    res[i + j] += a[i] * b[j];
                }
            }
            return res;
        }
        int k = n >> 1;
        vll a1(a.begin(), a.begin() + k);
        vll a2(a.begin() + k, a.end());
        vll b1(b.begin(), b.begin() + k);
        vll b2(b.begin() + k, b.end());
        vll a1b1 = karatsubaMultiply(a1, b1);
        vll a2b2 = karatsubaMultiply(a2, b2);
        for (int i = 0; i < k; i++) a2[i] += a1[i];
        for (int i = 0; i < k; i++) b2[i] += b1[i];
        vll r = karatsubaMultiply(a2, b2);
        for (int i = 0; i < (int) a1b1.size(); i++) r[i] -= a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++) r[i] -= a2b2[i];

        for (int i = 0; i < (int) r.size(); i++) res[i + k] += r[i];
        for (int i = 0; i < (int) a1b1.size(); i++) res[i] += a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++) res[i + n] += a2b2[i];
        return res;
    }
    void operator*=(const BI& v) {
        *this = *this * v;
    }
    BI operator/(const BI& v) const {
        return divmod(*this, v).first;
    }
    void operator/=(const BI& v) {
        *this = *this / v;
    }
    BI operator%(const BI& v) const {
        return divmod(*this, v).second;
    }
    void operator%=(const BI& v) {
        *this = *this % v;
    }
};
```

#### [3]三分

```C++
//凸函数求极大值
//int
while (l + 1 < r) {
    int mid1 = l + r >> 1;
    int mid2 = mid1 + r >> 1;
    if (f(mid1) > f(mid2))r = mid2;
    else l = mid1;
}//l
//double
while (l + eps < r) {
    double mid1 = l + (r - l) / 3;
    double mid2 = r - (r - l) / 3;
    if (f(mid1) > f(mid2))r = mid2;
    else l = mid1;
}//l

//凹函数求极小值
//int
while (l + 1 < r) {
    int mid1 = l + r >> 1;
    int mid2 = mid1 + r >> 1;
    if (f(mid1) > f(mid2))l = mid1;
    else r = mid2;
}//r
//double
while (l + eps < r) {
    double mid1 = l + (r - l) / 3;
    double mid2 = r - (r - l) / 3;
    if (f(mid1) > f(mid2))l = mid1;
    else r = mid2;
}//l
```

#### [4]双指针

```C++
//快慢指针模板   ->一般用于满足单调性，维护可变区间的权值或权值和的信息
        for (int i = 1, j = 1; i <= n; i++) {
            while (j <= n && 快指针跑的条件) {
                其余操作
                    j++;
                其余操作
            }
            if (满足条件)ans = 更新答案
                慢指针跑之前进行的操作
        }

        //对撞指针  ->一般用于求指定和的对数
        int l = 1, r = n;
        while (l < r) {
            while (a[l] + a[r] < k && l < r)l++;
            if (a[l] + a[r] >= k && l < r)ans++, l++, r--;
            else break;
        }
```

#### [5]线性基

```C++
template <typename T>
struct LinearBasis {
    vector<T> d, p;
    bool flag = false;

    LinearBasis() {}
    LinearBasis(int k) {
        init(k);
    }

    void init(int k) {
        d.assign(k, T());
        flag = T();
    }
    bool insert(T x) {
        for (int i = d.size() - 1; ~i; i--) {
            if (x >> i & 1) {
                if (!d[i]) return d[i] = x;
                x ^= d[i];
            }
        }
        return !(flag = true);
    }
    bool has(T x) {
        for (int i = d.size() - 1; ~i; i--) {
            if (x >> i & 1) {
                x ^= p[i];
            }
        }
        return x == 0;
    }
    T max(T x = T()) {
        for (int i = d.size() - 1; ~i; i--) {
            if (d[i] && ~x >> i & 1) x ^= d[i];
        }
        return x;
    }
    T min(T x = T()) {
        for (int i = d.size() - 1; ~i; i--) {
            if (d[i] && x >> i & 1) x ^= d[i];
        }
        return x;
    }
    void rebuild() {
        p.clear();
        for (int i = d.size() - 1; ~i; i--) {
            for (int j = i - 1; ~j; j--) {
                if (d[i] >> j & 1) d[i] ^= d[j];
            }
        }
        for (int i = 0; i < d.size(); i++) {
            if (d[i]) p.push_back(d[i]);
        }
    }
    T kth(i64 k) {
        k -= flag;
        if (!k) return 0;
        rebuild();
        if (k >= T(1) << p.size()) return -1;
        T x = 0;
        for (int i = 0; i < p.size(); i++) {
            if (k >> i & 1) x ^= p[i];
        }
        return x;
    }
};

template <typename T>
LinearBasis<T> operator+(const LinearBasis<T>& a, const LinearBasis<T>& b) {
    LinearBasis<T> c(a);
    for (int i = c.d.size() - 1; ~i; i--) {
        if (b.d[i]) c.insert(b.d[i]);
    }
    return c;
}
```

#### [6]分数类

```C++
struct Fraction {
    i64 a, b;
    i64 sign(i64 x) { return (x > 0 ? 1 : -1); }
    Fraction() :a(0), b(1) {}
    Fraction(i64 x) :a(x), b(1) {}
    Fraction(i64 x, i64 y) {
        i64 m = __gcd(abs(x), abs(y));
        a = x / m * sign(y);
        if (a == 0)b = 1; else b = abs(y / m);
    }
    i64 get_M() { return b; }
    i64 get_Z() { return a; }
    Fraction operator+(const Fraction& f) {
        i64 m = __gcd(b, f.b);
        return Fraction(f.b / m * a + b / m * f.a, b / m * f.b);
    }
    Fraction operator-(const Fraction& f) {
        i64 m = __gcd(b, f.b);
        return Fraction(f.b / m * a - b / m * f.a, b / m * f.b);
    }
    Fraction operator*(const Fraction& f) {
        i64 m1 = __gcd(abs(a), f.b);
        i64 m2 = __gcd(b, abs(f.a));
        return Fraction((a / m1) * (f.a / m2), (b / m2) * (f.b / m1));
    }
    Fraction operator/(const Fraction& f) {
        return (*this) * Fraction(f.b, f.a);
    }
    friend ostream& operator << (ostream& out, const Fraction& f) {
        if (f.a == 0) cout << 0;
        else if (f.b == 1) cout << f.a;
        else cout << f.a << '/' << f.b;
        return out;
    }
};
using F = Fraction;
```

#### [7]快读

```C++
char buf[1 << 20], * p1, * p2;
#define gc() (p1 == p2 ? (p2 = buf + fread(p1 = buf, 1, 1 << 20, stdin), p1 == p2 ? EOF : *p1++) : *p1++)
#define read() ({\
    int x = 0, f = 1;\
    char c = gc();\
    while(c < '0' || c > '9') f = (c == '-') ? -1 : 1, c = gc();\
    while(c >= '0' && c <= '9') x = x * 10 + (c & 15), c = gc();\
    f * x;\
})
```

#### [8]进制转化

```C++
string dict = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
string to(int n, int c) {
	string res = "";
	if (n == 0)return "0";
	while (n) {
		res = dict[n%c] + res;
		n /= c;
	}
	return res;
}
```

#### [9]Buil内置函数

```C++
    //__builtin_popcount() 1的个数
    //__builtin_ctz() 右边起连续0的个数
    //__builtin_clz() 左边起连续0的个数
    //可以加ll参数变为i64
```

#### [10]根号

```C++
i64 _sqrt(i64 n) {
    i64 x = sqrt(n);
    if (x * x > n)x--;
    return x;
}
```

#### [11]除

```C++
i64 ceilDiv(i64 n, i64 m) {
    if (n >= 0) {
        return (n + m - 1) / m;
    }
    else {
        return n / m;
    }
}

i64 floorDiv(i64 n, i64 m) {
    if (n >= 0) {
        return n / m;
    }
    else {
        return (n - m + 1) / m;
    }
}
```

#### [12]归并

```C++
vector<int>tmp(n + 5), q(n + 5);
i64 ans = 0;
auto merge_sort = [&](auto self, int l, int r)->void {
	if (l >= r) return;
	int mid = l + r >> 1;
	self(self, l, mid);
	self(self, mid + 1, r);
	int k = l, i = l, j = mid + 1;
	while (i <= mid && j <= r)
		if (q[i] <= q[j]) tmp[k++] = q[i++];
		else tmp[k++] = q[j++], ans += mid - i + 1;
	while (i <= mid) tmp[k++] = q[i++];
	while (j <= r) tmp[k++] = q[j++];
	for (i = l; i <= r; i++) q[i] = tmp[i];
};
```

#### [13]重载map

```C++
struct myhash {
    static uint64_t fxn(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator ()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return fxn(x + FIXED_RANDOM);
    }
};
```

#### [14]随机

```C++
mt19937_64 rng(random_device{}());
mt19937_64 rgen(chrono::steady_clock::now().time_since_epoch().count());
```

#### [15] 取模类

```C++
template<int MD> u32 down(u32 x) {
    return x >= MD ? x - MD : x;
}
template<int MD> i64 down(i64 x) {
    x %= MD; return x < 0 ? x + MD : x;
}

template<int MD>
struct mint {
    u32 x;
    mint() = default;
    mint(i64 x) : x(down<MD>(x)) {}
    friend istream& operator>>(istream& in, mint& a) { return in >> a.x; }
    friend ostream& operator<<(ostream& out, mint a) { return out << a.x; }
    friend mint operator+(mint a, mint b) { return down<MD>(a.x + b.x); }
    friend mint operator-(mint a, mint b) { return down<MD>(a.x - b.x + MD); }
    friend mint operator*(mint a, mint b) { return 1ULL * a.x * b.x % MD; }
    friend mint operator/(mint a, mint b) { return a * ~b; }
    friend mint operator^(mint a, i64 b) { mint ans = 1; for (; b; b >>= 1, a *= a) if (b & 1) ans *= a; return ans; }
    friend mint operator~(mint a) { return a ^ (MD - 2); }
    friend mint operator-(mint a) { return down<MD>(MD - a.x); }
    friend mint& operator+=(mint& a, mint b) { return a = a + b; }
    friend mint& operator-=(mint& a, mint b) { return a = a - b; }
    friend mint& operator*=(mint& a, mint b) { return a = a * b; }
    friend mint& operator/=(mint& a, mint b) { return a = a / b; }
    friend mint& operator^=(mint& a, i64 b) { return a = a ^ b; }
    friend bool operator==(mint a, mint b) { return a.x == b.x; }
    friend bool operator!=(mint a, mint b) { return !(a == b); }
    static vector<mint> __inv(int n) { vector<mint>inv(n + 1); inv[1] = 1; for (int i = 2; i <= n; i++)inv[i] = MD - 1LL * MD / i * inv[MD % i].x % MD; return inv; }
};
using Z = mint<(int)1e9 + 7>;
```



# DP

#### [1]数位DP

```C++
int A[20];
i64 dp[20][state];

i64 dfs(int pos,/*state变量*/, bool lead, bool limit) {
    if (pos == 0)return 1;
    if (!limit && !lead && dp[pos][state] != -1)return dp[pos][state];
    int up = limit ? A[pos] : 9;
    i64 ans = 0;
    for (int i = 0; i <= up; i++) {
        if ()...;
        else if ()...;
        ans += dfs(pos - 1,/*状态转移*/, lead && i == 0, limit && i == A[pos]);
    }
    if (!limit && !lead)dp[pos][state] = ans;
    /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/
    return ans;
}

i64 part(i64 x) {
    int len = 0;
    while (x) { A[++len] = x % 10; x /= 10; }
    memset(dp, -1, sizeof dp);
    return dfs(len, /*state*/, 1, 1);
}
/*
犯过的错误1：state为pre，合法条件是相邻之差>=2,当我仍然是前导0的时候，pre传参应该为幺元
*/
```

#### [2]

```C++
//最小点覆盖
    auto dfs = [&] (auto self, int x, int fa)->void {
        for (auto y : g[x]) {
            if (y == fa)continue;
            self(self, y, x);
            dp[x][0] += dp[y][1];
            dp[x][1] += min(dp[y][1], dp[y][0]);
        }
        dp[x][1]++;
    };
    dfs(dfs, 0, -1);

    cout << min(dp[0][0], dp[0][1]);

    
    //最小支配集
    auto dfs = [&] (auto self, int x, int fa)->void {
        int t = inf;
        dp[x][1] = w[x];
        for (auto y : g[x]) {
            if (y == fa)continue;
            self(self, y, x);
            dp[x][0] += min(dp[y][1], dp[y][2]);
            dp[x][1] += min({ dp[y][0], dp[y][1], dp[y][2] });
            dp[x][2] += min(dp[y][1], dp[y][2]);
            t = min(t, dp[y][1] - min(dp[y][1], dp[y][2]));
        }
        dp[x][2] += t;
    };
    dfs(dfs, 1, -1);

    cout << min(dp[1][1], dp[1][2]);
```

# 环

```C++
vector<int>vis(n + 1), fa(n + 1), ins(n + 1);
    vector<vector<int>>cys;
    auto dfs = [&] (auto self, int x, int FA)->void {
        ins[x] = vis[x] = 1;
        fa[x] = FA;
        for (int y : g[x]) {
            if (y == FA)continue;
            if (!vis[y]) {
                self(self, y, x);
            } else if (ins[y]) {
                vector<int>cy;
                cy.push_back(y);
                for (int cur = x; cur != y; cur = fa[cur]) {
                    cy.push_back(cur);
                }
                cy.push_back(y);
                cys.push_back(cy);
            }
            ins[x] = 0;
        }
    };

    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            dfs(dfs, i, -1);
        }
    }
```

```C++
//如果是 Linux/Mac，可以用 diff 代替 fc，用 cp 代替 copy。
    int t = 0;
    while (1) {
        cout << "test: " << ++t << "\n";
        system("data.exe > data.in");
        system("std.exe < data.in > std.out");
        system("wa.exe < data.in > wa.out");
        if (system("fc std.out wa.out > diff.log")) {
            string cmd = "copy data.in fail_" + to_string(t) + ".in";
            system(cmd.c_str());
            cout << "WA" << endl;
            break;
        }
        cout << "AC" << endl;
    }
```

